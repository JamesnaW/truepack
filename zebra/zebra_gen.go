package zebra

// NOTE: THIS FILE WAS PRODUCED BY THE
// GREENPACK CODE GENERATION TOOL (github.com/glycerine/greenpack)
// DO NOT EDIT

import (
	"github.com/glycerine/greenpack/msgp"
)

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *Field) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var field []byte
	_ = field
	const maxFields0zjta = 11

	// -- templateDecodeMsg starts here--
	var totalEncodedFields0zjta uint32
	totalEncodedFields0zjta, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	encodedFieldsLeft0zjta := totalEncodedFields0zjta
	missingFieldsLeft0zjta := maxFields0zjta - totalEncodedFields0zjta

	var nextMiss0zjta int32 = -1
	var found0zjta [maxFields0zjta]bool
	var curField0zjta string

doneWithStruct0zjta:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft0zjta > 0 || missingFieldsLeft0zjta > 0 {
		//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft0zjta, missingFieldsLeft0zjta, msgp.ShowFound(found0zjta[:]), decodeMsgFieldOrder0zjta)
		if encodedFieldsLeft0zjta > 0 {
			encodedFieldsLeft0zjta--
			field, err = dc.ReadMapKeyPtr()
			if err != nil {
				return
			}
			curField0zjta = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss0zjta < 0 {
				// tell the reader to only give us Nils
				// until further notice.
				dc.PushAlwaysNil()
				nextMiss0zjta = 0
			}
			for nextMiss0zjta < maxFields0zjta && (found0zjta[nextMiss0zjta] || decodeMsgFieldSkip0zjta[nextMiss0zjta]) {
				nextMiss0zjta++
			}
			if nextMiss0zjta == maxFields0zjta {
				// filled all the empty fields!
				break doneWithStruct0zjta
			}
			missingFieldsLeft0zjta--
			curField0zjta = decodeMsgFieldOrder0zjta[nextMiss0zjta]
		}
		//fmt.Printf("switching on curField: '%v'\n", curField0zjta)
		switch curField0zjta {
		// -- templateDecodeMsg ends here --

		case "Zid__i64":
			found0zjta[0] = true
			z.Zid, err = dc.ReadInt64()
			if err != nil {
				return
			}
		case "FieldGoName__str":
			found0zjta[1] = true
			z.FieldGoName, err = dc.ReadString()
			if err != nil {
				return
			}
		case "FieldTagName__str":
			found0zjta[2] = true
			z.FieldTagName, err = dc.ReadString()
			if err != nil {
				return
			}
		case "FieldTypeStr__str":
			found0zjta[3] = true
			z.FieldTypeStr, err = dc.ReadString()
			if err != nil {
				return
			}
		case "FieldCategory__":
			found0zjta[4] = true
			{
				var zjhp uint64
				zjhp, err = dc.ReadUint64()
				z.FieldCategory = Zkind(zjhp)
			}
			if err != nil {
				return
			}
		case "FieldPrimitive__":
			found0zjta[5] = true
			{
				var zcbh uint64
				zcbh, err = dc.ReadUint64()
				z.FieldPrimitive = Zkind(zcbh)
			}
			if err != nil {
				return
			}
		case "FieldFullType__ptr":
			found0zjta[6] = true
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}

				if z.FieldFullType != nil {
					dc.PushAlwaysNil()
					err = z.FieldFullType.DecodeMsg(dc)
					if err != nil {
						return
					}
					dc.PopAlwaysNil()
				}
			} else {
				// not Nil, we have something to read

				if z.FieldFullType == nil {
					z.FieldFullType = new(Ztype)
				}
				err = z.FieldFullType.DecodeMsg(dc)
				if err != nil {
					return
				}
			}
		case "OmitEmpty__boo":
			found0zjta[7] = true
			z.OmitEmpty, err = dc.ReadBool()
			if err != nil {
				return
			}
		case "Skip__boo":
			found0zjta[8] = true
			z.Skip, err = dc.ReadBool()
			if err != nil {
				return
			}
		case "Deprecated__boo":
			found0zjta[9] = true
			z.Deprecated, err = dc.ReadBool()
			if err != nil {
				return
			}
		case "ShowZero__boo":
			found0zjta[10] = true
			z.ShowZero, err = dc.ReadBool()
			if err != nil {
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				return
			}
		}
	}
	if nextMiss0zjta != -1 {
		dc.PopAlwaysNil()
	}

	if sawTopNil {
		dc.PopAlwaysNil()
	}

	if p, ok := interface{}(z).(msgp.PostLoad); ok {
		p.PostLoadHook()
	}

	return
}

// fields of Field
var decodeMsgFieldOrder0zjta = []string{"Zid__i64", "FieldGoName__str", "FieldTagName__str", "FieldTypeStr__str", "FieldCategory__", "FieldPrimitive__", "FieldFullType__ptr", "OmitEmpty__boo", "Skip__boo", "Deprecated__boo", "ShowZero__boo"}

var decodeMsgFieldSkip0zjta = []bool{false, false, false, false, false, false, false, false, false, false, false}

// fieldsNotEmpty supports omitempty tags
func (z *Field) fieldsNotEmpty(isempty []bool) uint32 {
	if len(isempty) == 0 {
		return 11
	}
	var fieldsInUse uint32 = 11
	isempty[2] = (len(z.FieldTagName) == 0) // string, omitempty
	if isempty[2] {
		fieldsInUse--
	}
	isempty[3] = (len(z.FieldTypeStr) == 0) // string, omitempty
	if isempty[3] {
		fieldsInUse--
	}
	isempty[4] = (z.FieldCategory == 0) // number, omitempty
	if isempty[4] {
		fieldsInUse--
	}
	isempty[5] = (z.FieldPrimitive == 0) // number, omitempty
	if isempty[5] {
		fieldsInUse--
	}
	isempty[6] = (z.FieldFullType == nil) // pointer, omitempty
	if isempty[6] {
		fieldsInUse--
	}
	isempty[7] = (!z.OmitEmpty) // bool, omitempty
	if isempty[7] {
		fieldsInUse--
	}
	isempty[8] = (!z.Skip) // bool, omitempty
	if isempty[8] {
		fieldsInUse--
	}
	isempty[9] = (!z.Deprecated) // bool, omitempty
	if isempty[9] {
		fieldsInUse--
	}
	isempty[10] = (!z.ShowZero) // bool, omitempty
	if isempty[10] {
		fieldsInUse--
	}

	return fieldsInUse
}

// EncodeMsg implements msgp.Encodable
func (z *Field) EncodeMsg(en *msgp.Writer) (err error) {
	if p, ok := interface{}(z).(msgp.PreSave); ok {
		p.PreSaveHook()
	}

	// honor the omitempty tags
	var empty_zeje [11]bool
	fieldsInUse_zvsl := z.fieldsNotEmpty(empty_zeje[:])

	// map header
	err = en.WriteMapHeader(fieldsInUse_zvsl)
	if err != nil {
		return err
	}

	// write "Zid__i64"
	err = en.Append(0xa8, 0x5a, 0x69, 0x64, 0x5f, 0x5f, 0x69, 0x36, 0x34)
	if err != nil {
		return err
	}
	err = en.WriteInt64(z.Zid)
	if err != nil {
		return
	}
	// write "FieldGoName__str"
	err = en.Append(0xb0, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x47, 0x6f, 0x4e, 0x61, 0x6d, 0x65, 0x5f, 0x5f, 0x73, 0x74, 0x72)
	if err != nil {
		return err
	}
	err = en.WriteString(z.FieldGoName)
	if err != nil {
		return
	}
	if !empty_zeje[2] {
		// write "FieldTagName__str"
		err = en.Append(0xb1, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x54, 0x61, 0x67, 0x4e, 0x61, 0x6d, 0x65, 0x5f, 0x5f, 0x73, 0x74, 0x72)
		if err != nil {
			return err
		}
		err = en.WriteString(z.FieldTagName)
		if err != nil {
			return
		}
	}

	if !empty_zeje[3] {
		// write "FieldTypeStr__str"
		err = en.Append(0xb1, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x54, 0x79, 0x70, 0x65, 0x53, 0x74, 0x72, 0x5f, 0x5f, 0x73, 0x74, 0x72)
		if err != nil {
			return err
		}
		err = en.WriteString(z.FieldTypeStr)
		if err != nil {
			return
		}
	}

	if !empty_zeje[4] {
		// write "FieldCategory__"
		err = en.Append(0xaf, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x5f, 0x5f)
		if err != nil {
			return err
		}
		err = en.WriteUint64(uint64(z.FieldCategory))
		if err != nil {
			return
		}
	}

	if !empty_zeje[5] {
		// write "FieldPrimitive__"
		err = en.Append(0xb0, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x50, 0x72, 0x69, 0x6d, 0x69, 0x74, 0x69, 0x76, 0x65, 0x5f, 0x5f)
		if err != nil {
			return err
		}
		err = en.WriteUint64(uint64(z.FieldPrimitive))
		if err != nil {
			return
		}
	}

	if !empty_zeje[6] {
		// write "FieldFullType__ptr"
		err = en.Append(0xb2, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x46, 0x75, 0x6c, 0x6c, 0x54, 0x79, 0x70, 0x65, 0x5f, 0x5f, 0x70, 0x74, 0x72)
		if err != nil {
			return err
		}
		if z.FieldFullType == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.FieldFullType.EncodeMsg(en)
			if err != nil {
				return
			}
		}
	}

	if !empty_zeje[7] {
		// write "OmitEmpty__boo"
		err = en.Append(0xae, 0x4f, 0x6d, 0x69, 0x74, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x5f, 0x5f, 0x62, 0x6f, 0x6f)
		if err != nil {
			return err
		}
		err = en.WriteBool(z.OmitEmpty)
		if err != nil {
			return
		}
	}

	if !empty_zeje[8] {
		// write "Skip__boo"
		err = en.Append(0xa9, 0x53, 0x6b, 0x69, 0x70, 0x5f, 0x5f, 0x62, 0x6f, 0x6f)
		if err != nil {
			return err
		}
		err = en.WriteBool(z.Skip)
		if err != nil {
			return
		}
	}

	if !empty_zeje[9] {
		// write "Deprecated__boo"
		err = en.Append(0xaf, 0x44, 0x65, 0x70, 0x72, 0x65, 0x63, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x5f, 0x62, 0x6f, 0x6f)
		if err != nil {
			return err
		}
		err = en.WriteBool(z.Deprecated)
		if err != nil {
			return
		}
	}

	if !empty_zeje[10] {
		// write "ShowZero__boo"
		err = en.Append(0xad, 0x53, 0x68, 0x6f, 0x77, 0x5a, 0x65, 0x72, 0x6f, 0x5f, 0x5f, 0x62, 0x6f, 0x6f)
		if err != nil {
			return err
		}
		err = en.WriteBool(z.ShowZero)
		if err != nil {
			return
		}
	}

	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Field) MarshalMsg(b []byte) (o []byte, err error) {
	if p, ok := interface{}(z).(msgp.PreSave); ok {
		p.PreSaveHook()
	}

	o = msgp.Require(b, z.Msgsize())

	// honor the omitempty tags
	var empty [11]bool
	fieldsInUse := z.fieldsNotEmpty(empty[:])
	o = msgp.AppendMapHeader(o, fieldsInUse)

	// string "Zid__i64"
	o = append(o, 0xa8, 0x5a, 0x69, 0x64, 0x5f, 0x5f, 0x69, 0x36, 0x34)
	o = msgp.AppendInt64(o, z.Zid)
	// string "FieldGoName__str"
	o = append(o, 0xb0, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x47, 0x6f, 0x4e, 0x61, 0x6d, 0x65, 0x5f, 0x5f, 0x73, 0x74, 0x72)
	o = msgp.AppendString(o, z.FieldGoName)
	if !empty[2] {
		// string "FieldTagName__str"
		o = append(o, 0xb1, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x54, 0x61, 0x67, 0x4e, 0x61, 0x6d, 0x65, 0x5f, 0x5f, 0x73, 0x74, 0x72)
		o = msgp.AppendString(o, z.FieldTagName)
	}

	if !empty[3] {
		// string "FieldTypeStr__str"
		o = append(o, 0xb1, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x54, 0x79, 0x70, 0x65, 0x53, 0x74, 0x72, 0x5f, 0x5f, 0x73, 0x74, 0x72)
		o = msgp.AppendString(o, z.FieldTypeStr)
	}

	if !empty[4] {
		// string "FieldCategory__"
		o = append(o, 0xaf, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x5f, 0x5f)
		o = msgp.AppendUint64(o, uint64(z.FieldCategory))
	}

	if !empty[5] {
		// string "FieldPrimitive__"
		o = append(o, 0xb0, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x50, 0x72, 0x69, 0x6d, 0x69, 0x74, 0x69, 0x76, 0x65, 0x5f, 0x5f)
		o = msgp.AppendUint64(o, uint64(z.FieldPrimitive))
	}

	if !empty[6] {
		// string "FieldFullType__ptr"
		o = append(o, 0xb2, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x46, 0x75, 0x6c, 0x6c, 0x54, 0x79, 0x70, 0x65, 0x5f, 0x5f, 0x70, 0x74, 0x72)
		if z.FieldFullType == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.FieldFullType.MarshalMsg(o)
			if err != nil {
				return
			}
		}
	}

	if !empty[7] {
		// string "OmitEmpty__boo"
		o = append(o, 0xae, 0x4f, 0x6d, 0x69, 0x74, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x5f, 0x5f, 0x62, 0x6f, 0x6f)
		o = msgp.AppendBool(o, z.OmitEmpty)
	}

	if !empty[8] {
		// string "Skip__boo"
		o = append(o, 0xa9, 0x53, 0x6b, 0x69, 0x70, 0x5f, 0x5f, 0x62, 0x6f, 0x6f)
		o = msgp.AppendBool(o, z.Skip)
	}

	if !empty[9] {
		// string "Deprecated__boo"
		o = append(o, 0xaf, 0x44, 0x65, 0x70, 0x72, 0x65, 0x63, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x5f, 0x62, 0x6f, 0x6f)
		o = msgp.AppendBool(o, z.Deprecated)
	}

	if !empty[10] {
		// string "ShowZero__boo"
		o = append(o, 0xad, 0x53, 0x68, 0x6f, 0x77, 0x5a, 0x65, 0x72, 0x6f, 0x5f, 0x5f, 0x62, 0x6f, 0x6f)
		o = msgp.AppendBool(o, z.ShowZero)
	}

	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Field) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.UnmarshalMsgWithCfg(bts, nil)
}
func (z *Field) UnmarshalMsgWithCfg(bts []byte, cfg *msgp.RuntimeConfig) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	nbs.Init(cfg)
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var field []byte
	_ = field
	const maxFields1zzdc = 11

	// -- templateUnmarshalMsg starts here--
	var totalEncodedFields1zzdc uint32
	if !nbs.AlwaysNil {
		totalEncodedFields1zzdc, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			return
		}
	}
	encodedFieldsLeft1zzdc := totalEncodedFields1zzdc
	missingFieldsLeft1zzdc := maxFields1zzdc - totalEncodedFields1zzdc

	var nextMiss1zzdc int32 = -1
	var found1zzdc [maxFields1zzdc]bool
	var curField1zzdc string

doneWithStruct1zzdc:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft1zzdc > 0 || missingFieldsLeft1zzdc > 0 {
		//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft1zzdc, missingFieldsLeft1zzdc, msgp.ShowFound(found1zzdc[:]), unmarshalMsgFieldOrder1zzdc)
		if encodedFieldsLeft1zzdc > 0 {
			encodedFieldsLeft1zzdc--
			field, bts, err = nbs.ReadMapKeyZC(bts)
			if err != nil {
				return
			}
			curField1zzdc = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss1zzdc < 0 {
				// set bts to contain just mnil (0xc0)
				bts = nbs.PushAlwaysNil(bts)
				nextMiss1zzdc = 0
			}
			for nextMiss1zzdc < maxFields1zzdc && (found1zzdc[nextMiss1zzdc] || unmarshalMsgFieldSkip1zzdc[nextMiss1zzdc]) {
				nextMiss1zzdc++
			}
			if nextMiss1zzdc == maxFields1zzdc {
				// filled all the empty fields!
				break doneWithStruct1zzdc
			}
			missingFieldsLeft1zzdc--
			curField1zzdc = unmarshalMsgFieldOrder1zzdc[nextMiss1zzdc]
		}
		//fmt.Printf("switching on curField: '%v'\n", curField1zzdc)
		switch curField1zzdc {
		// -- templateUnmarshalMsg ends here --

		case "Zid__i64":
			found1zzdc[0] = true
			z.Zid, bts, err = nbs.ReadInt64Bytes(bts)

			if err != nil {
				return
			}
		case "FieldGoName__str":
			found1zzdc[1] = true
			z.FieldGoName, bts, err = nbs.ReadStringBytes(bts)

			if err != nil {
				return
			}
		case "FieldTagName__str":
			found1zzdc[2] = true
			z.FieldTagName, bts, err = nbs.ReadStringBytes(bts)

			if err != nil {
				return
			}
		case "FieldTypeStr__str":
			found1zzdc[3] = true
			z.FieldTypeStr, bts, err = nbs.ReadStringBytes(bts)

			if err != nil {
				return
			}
		case "FieldCategory__":
			found1zzdc[4] = true
			{
				var zclp uint64
				zclp, bts, err = nbs.ReadUint64Bytes(bts)

				if err != nil {
					return
				}
				z.FieldCategory = Zkind(zclp)
			}
		case "FieldPrimitive__":
			found1zzdc[5] = true
			{
				var zvpo uint64
				zvpo, bts, err = nbs.ReadUint64Bytes(bts)

				if err != nil {
					return
				}
				z.FieldPrimitive = Zkind(zvpo)
			}
		case "FieldFullType__ptr":
			found1zzdc[6] = true
			if nbs.AlwaysNil {
				if z.FieldFullType != nil {
					z.FieldFullType.UnmarshalMsg(msgp.OnlyNilSlice)
				}
			} else {
				// not nbs.AlwaysNil
				if msgp.IsNil(bts) {
					bts = bts[1:]
					if nil != z.FieldFullType {
						z.FieldFullType.UnmarshalMsg(msgp.OnlyNilSlice)
					}
				} else {
					// not nbs.AlwaysNil and not IsNil(bts): have something to read

					if z.FieldFullType == nil {
						z.FieldFullType = new(Ztype)
					}
					bts, err = z.FieldFullType.UnmarshalMsg(bts)
					if err != nil {
						return
					}
					if err != nil {
						return
					}
				}
			}
		case "OmitEmpty__boo":
			found1zzdc[7] = true
			z.OmitEmpty, bts, err = nbs.ReadBoolBytes(bts)

			if err != nil {
				return
			}
		case "Skip__boo":
			found1zzdc[8] = true
			z.Skip, bts, err = nbs.ReadBoolBytes(bts)

			if err != nil {
				return
			}
		case "Deprecated__boo":
			found1zzdc[9] = true
			z.Deprecated, bts, err = nbs.ReadBoolBytes(bts)

			if err != nil {
				return
			}
		case "ShowZero__boo":
			found1zzdc[10] = true
			z.ShowZero, bts, err = nbs.ReadBoolBytes(bts)

			if err != nil {
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				return
			}
		}
	}
	if nextMiss1zzdc != -1 {
		bts = nbs.PopAlwaysNil()
	}

	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	if p, ok := interface{}(z).(msgp.PostLoad); ok {
		p.PostLoadHook()
	}

	return
}

// fields of Field
var unmarshalMsgFieldOrder1zzdc = []string{"Zid__i64", "FieldGoName__str", "FieldTagName__str", "FieldTypeStr__str", "FieldCategory__", "FieldPrimitive__", "FieldFullType__ptr", "OmitEmpty__boo", "Skip__boo", "Deprecated__boo", "ShowZero__boo"}

var unmarshalMsgFieldSkip1zzdc = []bool{false, false, false, false, false, false, false, false, false, false, false}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Field) Msgsize() (s int) {
	s = 1 + 9 + msgp.Int64Size + 17 + msgp.StringPrefixSize + len(z.FieldGoName) + 18 + msgp.StringPrefixSize + len(z.FieldTagName) + 18 + msgp.StringPrefixSize + len(z.FieldTypeStr) + 16 + msgp.Uint64Size + 17 + msgp.Uint64Size + 19
	if z.FieldFullType == nil {
		s += msgp.NilSize
	} else {
		s += z.FieldFullType.Msgsize()
	}
	s += 15 + msgp.BoolSize + 10 + msgp.BoolSize + 16 + msgp.BoolSize + 14 + msgp.BoolSize
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *Schema) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var field []byte
	_ = field
	const maxFields2zenr = 5

	// -- templateDecodeMsg starts here--
	var totalEncodedFields2zenr uint32
	totalEncodedFields2zenr, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	encodedFieldsLeft2zenr := totalEncodedFields2zenr
	missingFieldsLeft2zenr := maxFields2zenr - totalEncodedFields2zenr

	var nextMiss2zenr int32 = -1
	var found2zenr [maxFields2zenr]bool
	var curField2zenr string

doneWithStruct2zenr:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft2zenr > 0 || missingFieldsLeft2zenr > 0 {
		//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft2zenr, missingFieldsLeft2zenr, msgp.ShowFound(found2zenr[:]), decodeMsgFieldOrder2zenr)
		if encodedFieldsLeft2zenr > 0 {
			encodedFieldsLeft2zenr--
			field, err = dc.ReadMapKeyPtr()
			if err != nil {
				return
			}
			curField2zenr = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss2zenr < 0 {
				// tell the reader to only give us Nils
				// until further notice.
				dc.PushAlwaysNil()
				nextMiss2zenr = 0
			}
			for nextMiss2zenr < maxFields2zenr && (found2zenr[nextMiss2zenr] || decodeMsgFieldSkip2zenr[nextMiss2zenr]) {
				nextMiss2zenr++
			}
			if nextMiss2zenr == maxFields2zenr {
				// filled all the empty fields!
				break doneWithStruct2zenr
			}
			missingFieldsLeft2zenr--
			curField2zenr = decodeMsgFieldOrder2zenr[nextMiss2zenr]
		}
		//fmt.Printf("switching on curField: '%v'\n", curField2zenr)
		switch curField2zenr {
		// -- templateDecodeMsg ends here --

		case "SourcePath__str":
			found2zenr[0] = true
			z.SourcePath, err = dc.ReadString()
			if err != nil {
				return
			}
		case "SourcePackage__str":
			found2zenr[1] = true
			z.SourcePackage, err = dc.ReadString()
			if err != nil {
				return
			}
		case "ZebraSchemaId__i64":
			found2zenr[2] = true
			z.ZebraSchemaId, err = dc.ReadInt64()
			if err != nil {
				return
			}
		case "Structs__map":
			found2zenr[3] = true
			var zkeu uint32
			zkeu, err = dc.ReadMapHeader()
			if err != nil {
				return
			}
			if z.Structs == nil && zkeu > 0 {
				z.Structs = make(map[string]*Struct, zkeu)
			} else if len(z.Structs) > 0 {
				for key, _ := range z.Structs {
					delete(z.Structs, key)
				}
			}
			for zkeu > 0 {
				zkeu--
				var zsoq string
				var zqhj *Struct
				zsoq, err = dc.ReadString()
				if err != nil {
					return
				}
				if dc.IsNil() {
					err = dc.ReadNil()
					if err != nil {
						return
					}

					zqhj = nil
				} else {
					if zqhj == nil {
						zqhj = new(Struct)
					}
					const maxFields3zuqd = 2

					// -- templateDecodeMsg starts here--
					var totalEncodedFields3zuqd uint32
					totalEncodedFields3zuqd, err = dc.ReadMapHeader()
					if err != nil {
						return
					}
					encodedFieldsLeft3zuqd := totalEncodedFields3zuqd
					missingFieldsLeft3zuqd := maxFields3zuqd - totalEncodedFields3zuqd

					var nextMiss3zuqd int32 = -1
					var found3zuqd [maxFields3zuqd]bool
					var curField3zuqd string

				doneWithStruct3zuqd:
					// First fill all the encoded fields, then
					// treat the remaining, missing fields, as Nil.
					for encodedFieldsLeft3zuqd > 0 || missingFieldsLeft3zuqd > 0 {
						//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft3zuqd, missingFieldsLeft3zuqd, msgp.ShowFound(found3zuqd[:]), decodeMsgFieldOrder3zuqd)
						if encodedFieldsLeft3zuqd > 0 {
							encodedFieldsLeft3zuqd--
							field, err = dc.ReadMapKeyPtr()
							if err != nil {
								return
							}
							curField3zuqd = msgp.UnsafeString(field)
						} else {
							//missing fields need handling
							if nextMiss3zuqd < 0 {
								// tell the reader to only give us Nils
								// until further notice.
								dc.PushAlwaysNil()
								nextMiss3zuqd = 0
							}
							for nextMiss3zuqd < maxFields3zuqd && (found3zuqd[nextMiss3zuqd] || decodeMsgFieldSkip3zuqd[nextMiss3zuqd]) {
								nextMiss3zuqd++
							}
							if nextMiss3zuqd == maxFields3zuqd {
								// filled all the empty fields!
								break doneWithStruct3zuqd
							}
							missingFieldsLeft3zuqd--
							curField3zuqd = decodeMsgFieldOrder3zuqd[nextMiss3zuqd]
						}
						//fmt.Printf("switching on curField: '%v'\n", curField3zuqd)
						switch curField3zuqd {
						// -- templateDecodeMsg ends here --

						case "StructName__str":
							found3zuqd[0] = true
							zqhj.StructName, err = dc.ReadString()
							if err != nil {
								return
							}
						case "Fields__slc":
							found3zuqd[1] = true
							var zldv uint32
							zldv, err = dc.ReadArrayHeader()
							if err != nil {
								return
							}
							if cap(zqhj.Fields) >= int(zldv) {
								zqhj.Fields = (zqhj.Fields)[:zldv]
							} else {
								zqhj.Fields = make([]Field, zldv)
							}
							for zeyn := range zqhj.Fields {
								err = zqhj.Fields[zeyn].DecodeMsg(dc)
								if err != nil {
									return
								}
							}
						default:
							err = dc.Skip()
							if err != nil {
								return
							}
						}
					}
					if nextMiss3zuqd != -1 {
						dc.PopAlwaysNil()
					}

				}
				z.Structs[zsoq] = zqhj
			}
		case "Imports__slc":
			found2zenr[4] = true
			var zkys uint32
			zkys, err = dc.ReadArrayHeader()
			if err != nil {
				return
			}
			if cap(z.Imports) >= int(zkys) {
				z.Imports = (z.Imports)[:zkys]
			} else {
				z.Imports = make([]string, zkys)
			}
			for zzbx := range z.Imports {
				z.Imports[zzbx], err = dc.ReadString()
				if err != nil {
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				return
			}
		}
	}
	if nextMiss2zenr != -1 {
		dc.PopAlwaysNil()
	}

	if sawTopNil {
		dc.PopAlwaysNil()
	}

	if p, ok := interface{}(z).(msgp.PostLoad); ok {
		p.PostLoadHook()
	}

	return
}

// fields of Schema
var decodeMsgFieldOrder2zenr = []string{"SourcePath__str", "SourcePackage__str", "ZebraSchemaId__i64", "Structs__map", "Imports__slc"}

var decodeMsgFieldSkip2zenr = []bool{false, false, false, false, false}

// fields of Struct
var decodeMsgFieldOrder3zuqd = []string{"StructName__str", "Fields__slc"}

var decodeMsgFieldSkip3zuqd = []bool{false, false}

// fieldsNotEmpty supports omitempty tags
func (z *Schema) fieldsNotEmpty(isempty []bool) uint32 {
	return 5
}

// EncodeMsg implements msgp.Encodable
func (z *Schema) EncodeMsg(en *msgp.Writer) (err error) {
	if p, ok := interface{}(z).(msgp.PreSave); ok {
		p.PreSaveHook()
	}

	// map header, size 5
	// write "SourcePath__str"
	err = en.Append(0x85, 0xaf, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x50, 0x61, 0x74, 0x68, 0x5f, 0x5f, 0x73, 0x74, 0x72)
	if err != nil {
		return err
	}
	err = en.WriteString(z.SourcePath)
	if err != nil {
		return
	}
	// write "SourcePackage__str"
	err = en.Append(0xb2, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x50, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65, 0x5f, 0x5f, 0x73, 0x74, 0x72)
	if err != nil {
		return err
	}
	err = en.WriteString(z.SourcePackage)
	if err != nil {
		return
	}
	// write "ZebraSchemaId__i64"
	err = en.Append(0xb2, 0x5a, 0x65, 0x62, 0x72, 0x61, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x49, 0x64, 0x5f, 0x5f, 0x69, 0x36, 0x34)
	if err != nil {
		return err
	}
	err = en.WriteInt64(z.ZebraSchemaId)
	if err != nil {
		return
	}
	// write "Structs__map"
	err = en.Append(0xac, 0x53, 0x74, 0x72, 0x75, 0x63, 0x74, 0x73, 0x5f, 0x5f, 0x6d, 0x61, 0x70)
	if err != nil {
		return err
	}
	err = en.WriteMapHeader(uint32(len(z.Structs)))
	if err != nil {
		return
	}
	for zsoq, zqhj := range z.Structs {
		err = en.WriteString(zsoq)
		if err != nil {
			return
		}
		if zqhj == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			// map header, size 2
			// write "StructName__str"
			err = en.Append(0x82, 0xaf, 0x53, 0x74, 0x72, 0x75, 0x63, 0x74, 0x4e, 0x61, 0x6d, 0x65, 0x5f, 0x5f, 0x73, 0x74, 0x72)
			if err != nil {
				return err
			}
			err = en.WriteString(zqhj.StructName)
			if err != nil {
				return
			}
			// write "Fields__slc"
			err = en.Append(0xab, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x73, 0x5f, 0x5f, 0x73, 0x6c, 0x63)
			if err != nil {
				return err
			}
			err = en.WriteArrayHeader(uint32(len(zqhj.Fields)))
			if err != nil {
				return
			}
			for zeyn := range zqhj.Fields {
				err = zqhj.Fields[zeyn].EncodeMsg(en)
				if err != nil {
					return
				}
			}
		}
	}
	// write "Imports__slc"
	err = en.Append(0xac, 0x49, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x73, 0x5f, 0x5f, 0x73, 0x6c, 0x63)
	if err != nil {
		return err
	}
	err = en.WriteArrayHeader(uint32(len(z.Imports)))
	if err != nil {
		return
	}
	for zzbx := range z.Imports {
		err = en.WriteString(z.Imports[zzbx])
		if err != nil {
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Schema) MarshalMsg(b []byte) (o []byte, err error) {
	if p, ok := interface{}(z).(msgp.PreSave); ok {
		p.PreSaveHook()
	}

	o = msgp.Require(b, z.Msgsize())
	// map header, size 5
	// string "SourcePath__str"
	o = append(o, 0x85, 0xaf, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x50, 0x61, 0x74, 0x68, 0x5f, 0x5f, 0x73, 0x74, 0x72)
	o = msgp.AppendString(o, z.SourcePath)
	// string "SourcePackage__str"
	o = append(o, 0xb2, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x50, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65, 0x5f, 0x5f, 0x73, 0x74, 0x72)
	o = msgp.AppendString(o, z.SourcePackage)
	// string "ZebraSchemaId__i64"
	o = append(o, 0xb2, 0x5a, 0x65, 0x62, 0x72, 0x61, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x49, 0x64, 0x5f, 0x5f, 0x69, 0x36, 0x34)
	o = msgp.AppendInt64(o, z.ZebraSchemaId)
	// string "Structs__map"
	o = append(o, 0xac, 0x53, 0x74, 0x72, 0x75, 0x63, 0x74, 0x73, 0x5f, 0x5f, 0x6d, 0x61, 0x70)
	o = msgp.AppendMapHeader(o, uint32(len(z.Structs)))
	for zsoq, zqhj := range z.Structs {
		o = msgp.AppendString(o, zsoq)
		if zqhj == nil {
			o = msgp.AppendNil(o)
		} else {
			// map header, size 2
			// string "StructName__str"
			o = append(o, 0x82, 0xaf, 0x53, 0x74, 0x72, 0x75, 0x63, 0x74, 0x4e, 0x61, 0x6d, 0x65, 0x5f, 0x5f, 0x73, 0x74, 0x72)
			o = msgp.AppendString(o, zqhj.StructName)
			// string "Fields__slc"
			o = append(o, 0xab, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x73, 0x5f, 0x5f, 0x73, 0x6c, 0x63)
			o = msgp.AppendArrayHeader(o, uint32(len(zqhj.Fields)))
			for zeyn := range zqhj.Fields {
				o, err = zqhj.Fields[zeyn].MarshalMsg(o)
				if err != nil {
					return
				}
			}
		}
	}
	// string "Imports__slc"
	o = append(o, 0xac, 0x49, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x73, 0x5f, 0x5f, 0x73, 0x6c, 0x63)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Imports)))
	for zzbx := range z.Imports {
		o = msgp.AppendString(o, z.Imports[zzbx])
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Schema) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.UnmarshalMsgWithCfg(bts, nil)
}
func (z *Schema) UnmarshalMsgWithCfg(bts []byte, cfg *msgp.RuntimeConfig) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	nbs.Init(cfg)
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var field []byte
	_ = field
	const maxFields4zrba = 5

	// -- templateUnmarshalMsg starts here--
	var totalEncodedFields4zrba uint32
	if !nbs.AlwaysNil {
		totalEncodedFields4zrba, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			return
		}
	}
	encodedFieldsLeft4zrba := totalEncodedFields4zrba
	missingFieldsLeft4zrba := maxFields4zrba - totalEncodedFields4zrba

	var nextMiss4zrba int32 = -1
	var found4zrba [maxFields4zrba]bool
	var curField4zrba string

doneWithStruct4zrba:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft4zrba > 0 || missingFieldsLeft4zrba > 0 {
		//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft4zrba, missingFieldsLeft4zrba, msgp.ShowFound(found4zrba[:]), unmarshalMsgFieldOrder4zrba)
		if encodedFieldsLeft4zrba > 0 {
			encodedFieldsLeft4zrba--
			field, bts, err = nbs.ReadMapKeyZC(bts)
			if err != nil {
				return
			}
			curField4zrba = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss4zrba < 0 {
				// set bts to contain just mnil (0xc0)
				bts = nbs.PushAlwaysNil(bts)
				nextMiss4zrba = 0
			}
			for nextMiss4zrba < maxFields4zrba && (found4zrba[nextMiss4zrba] || unmarshalMsgFieldSkip4zrba[nextMiss4zrba]) {
				nextMiss4zrba++
			}
			if nextMiss4zrba == maxFields4zrba {
				// filled all the empty fields!
				break doneWithStruct4zrba
			}
			missingFieldsLeft4zrba--
			curField4zrba = unmarshalMsgFieldOrder4zrba[nextMiss4zrba]
		}
		//fmt.Printf("switching on curField: '%v'\n", curField4zrba)
		switch curField4zrba {
		// -- templateUnmarshalMsg ends here --

		case "SourcePath__str":
			found4zrba[0] = true
			z.SourcePath, bts, err = nbs.ReadStringBytes(bts)

			if err != nil {
				return
			}
		case "SourcePackage__str":
			found4zrba[1] = true
			z.SourcePackage, bts, err = nbs.ReadStringBytes(bts)

			if err != nil {
				return
			}
		case "ZebraSchemaId__i64":
			found4zrba[2] = true
			z.ZebraSchemaId, bts, err = nbs.ReadInt64Bytes(bts)

			if err != nil {
				return
			}
		case "Structs__map":
			found4zrba[3] = true
			if nbs.AlwaysNil {
				if len(z.Structs) > 0 {
					for key, _ := range z.Structs {
						delete(z.Structs, key)
					}
				}

			} else {

				var zmmn uint32
				zmmn, bts, err = nbs.ReadMapHeaderBytes(bts)
				if err != nil {
					return
				}
				if z.Structs == nil && zmmn > 0 {
					z.Structs = make(map[string]*Struct, zmmn)
				} else if len(z.Structs) > 0 {
					for key, _ := range z.Structs {
						delete(z.Structs, key)
					}
				}
				for zmmn > 0 {
					var zsoq string
					var zqhj *Struct
					zmmn--
					zsoq, bts, err = nbs.ReadStringBytes(bts)
					if err != nil {
						return
					}
					// default gPtr logic.
					if nbs.PeekNil(bts) && zqhj == nil {
						// consume the nil
						bts, err = nbs.ReadNilBytes(bts)
						if err != nil {
							return
						}
					} else {
						// read as-if the wire has bytes, letting nbs take care of nils.

						if zqhj == nil {
							zqhj = new(Struct)
						}
						const maxFields5zhtd = 2

						// -- templateUnmarshalMsg starts here--
						var totalEncodedFields5zhtd uint32
						if !nbs.AlwaysNil {
							totalEncodedFields5zhtd, bts, err = nbs.ReadMapHeaderBytes(bts)
							if err != nil {
								return
							}
						}
						encodedFieldsLeft5zhtd := totalEncodedFields5zhtd
						missingFieldsLeft5zhtd := maxFields5zhtd - totalEncodedFields5zhtd

						var nextMiss5zhtd int32 = -1
						var found5zhtd [maxFields5zhtd]bool
						var curField5zhtd string

					doneWithStruct5zhtd:
						// First fill all the encoded fields, then
						// treat the remaining, missing fields, as Nil.
						for encodedFieldsLeft5zhtd > 0 || missingFieldsLeft5zhtd > 0 {
							//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft5zhtd, missingFieldsLeft5zhtd, msgp.ShowFound(found5zhtd[:]), unmarshalMsgFieldOrder5zhtd)
							if encodedFieldsLeft5zhtd > 0 {
								encodedFieldsLeft5zhtd--
								field, bts, err = nbs.ReadMapKeyZC(bts)
								if err != nil {
									return
								}
								curField5zhtd = msgp.UnsafeString(field)
							} else {
								//missing fields need handling
								if nextMiss5zhtd < 0 {
									// set bts to contain just mnil (0xc0)
									bts = nbs.PushAlwaysNil(bts)
									nextMiss5zhtd = 0
								}
								for nextMiss5zhtd < maxFields5zhtd && (found5zhtd[nextMiss5zhtd] || unmarshalMsgFieldSkip5zhtd[nextMiss5zhtd]) {
									nextMiss5zhtd++
								}
								if nextMiss5zhtd == maxFields5zhtd {
									// filled all the empty fields!
									break doneWithStruct5zhtd
								}
								missingFieldsLeft5zhtd--
								curField5zhtd = unmarshalMsgFieldOrder5zhtd[nextMiss5zhtd]
							}
							//fmt.Printf("switching on curField: '%v'\n", curField5zhtd)
							switch curField5zhtd {
							// -- templateUnmarshalMsg ends here --

							case "StructName__str":
								found5zhtd[0] = true
								zqhj.StructName, bts, err = nbs.ReadStringBytes(bts)

								if err != nil {
									return
								}
							case "Fields__slc":
								found5zhtd[1] = true
								if nbs.AlwaysNil {
									(zqhj.Fields) = (zqhj.Fields)[:0]
								} else {

									var zwne uint32
									zwne, bts, err = nbs.ReadArrayHeaderBytes(bts)
									if err != nil {
										return
									}
									if cap(zqhj.Fields) >= int(zwne) {
										zqhj.Fields = (zqhj.Fields)[:zwne]
									} else {
										zqhj.Fields = make([]Field, zwne)
									}
									for zeyn := range zqhj.Fields {
										bts, err = zqhj.Fields[zeyn].UnmarshalMsg(bts)
										if err != nil {
											return
										}
										if err != nil {
											return
										}
									}
								}
							default:
								bts, err = msgp.Skip(bts)
								if err != nil {
									return
								}
							}
						}
						if nextMiss5zhtd != -1 {
							bts = nbs.PopAlwaysNil()
						}

					}
					z.Structs[zsoq] = zqhj
				}
			}
		case "Imports__slc":
			found4zrba[4] = true
			if nbs.AlwaysNil {
				(z.Imports) = (z.Imports)[:0]
			} else {

				var zary uint32
				zary, bts, err = nbs.ReadArrayHeaderBytes(bts)
				if err != nil {
					return
				}
				if cap(z.Imports) >= int(zary) {
					z.Imports = (z.Imports)[:zary]
				} else {
					z.Imports = make([]string, zary)
				}
				for zzbx := range z.Imports {
					z.Imports[zzbx], bts, err = nbs.ReadStringBytes(bts)

					if err != nil {
						return
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				return
			}
		}
	}
	if nextMiss4zrba != -1 {
		bts = nbs.PopAlwaysNil()
	}

	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	if p, ok := interface{}(z).(msgp.PostLoad); ok {
		p.PostLoadHook()
	}

	return
}

// fields of Schema
var unmarshalMsgFieldOrder4zrba = []string{"SourcePath__str", "SourcePackage__str", "ZebraSchemaId__i64", "Structs__map", "Imports__slc"}

var unmarshalMsgFieldSkip4zrba = []bool{false, false, false, false, false}

// fields of Struct
var unmarshalMsgFieldOrder5zhtd = []string{"StructName__str", "Fields__slc"}

var unmarshalMsgFieldSkip5zhtd = []bool{false, false}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Schema) Msgsize() (s int) {
	s = 1 + 16 + msgp.StringPrefixSize + len(z.SourcePath) + 19 + msgp.StringPrefixSize + len(z.SourcePackage) + 19 + msgp.Int64Size + 13 + msgp.MapHeaderSize
	if z.Structs != nil {
		for zsoq, zqhj := range z.Structs {
			_ = zqhj
			_ = zsoq
			s += msgp.StringPrefixSize + len(zsoq)
			if zqhj == nil {
				s += msgp.NilSize
			} else {
				s += 1 + 16 + msgp.StringPrefixSize + len(zqhj.StructName) + 12 + msgp.ArrayHeaderSize
				for zeyn := range zqhj.Fields {
					s += zqhj.Fields[zeyn].Msgsize()
				}
			}
		}
	}
	s += 13 + msgp.ArrayHeaderSize
	for zzbx := range z.Imports {
		s += msgp.StringPrefixSize + len(z.Imports[zzbx])
	}
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *Struct) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var field []byte
	_ = field
	const maxFields6zyeg = 2

	// -- templateDecodeMsg starts here--
	var totalEncodedFields6zyeg uint32
	totalEncodedFields6zyeg, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	encodedFieldsLeft6zyeg := totalEncodedFields6zyeg
	missingFieldsLeft6zyeg := maxFields6zyeg - totalEncodedFields6zyeg

	var nextMiss6zyeg int32 = -1
	var found6zyeg [maxFields6zyeg]bool
	var curField6zyeg string

doneWithStruct6zyeg:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft6zyeg > 0 || missingFieldsLeft6zyeg > 0 {
		//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft6zyeg, missingFieldsLeft6zyeg, msgp.ShowFound(found6zyeg[:]), decodeMsgFieldOrder6zyeg)
		if encodedFieldsLeft6zyeg > 0 {
			encodedFieldsLeft6zyeg--
			field, err = dc.ReadMapKeyPtr()
			if err != nil {
				return
			}
			curField6zyeg = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss6zyeg < 0 {
				// tell the reader to only give us Nils
				// until further notice.
				dc.PushAlwaysNil()
				nextMiss6zyeg = 0
			}
			for nextMiss6zyeg < maxFields6zyeg && (found6zyeg[nextMiss6zyeg] || decodeMsgFieldSkip6zyeg[nextMiss6zyeg]) {
				nextMiss6zyeg++
			}
			if nextMiss6zyeg == maxFields6zyeg {
				// filled all the empty fields!
				break doneWithStruct6zyeg
			}
			missingFieldsLeft6zyeg--
			curField6zyeg = decodeMsgFieldOrder6zyeg[nextMiss6zyeg]
		}
		//fmt.Printf("switching on curField: '%v'\n", curField6zyeg)
		switch curField6zyeg {
		// -- templateDecodeMsg ends here --

		case "StructName__str":
			found6zyeg[0] = true
			z.StructName, err = dc.ReadString()
			if err != nil {
				return
			}
		case "Fields__slc":
			found6zyeg[1] = true
			var zngc uint32
			zngc, err = dc.ReadArrayHeader()
			if err != nil {
				return
			}
			if cap(z.Fields) >= int(zngc) {
				z.Fields = (z.Fields)[:zngc]
			} else {
				z.Fields = make([]Field, zngc)
			}
			for zkmr := range z.Fields {
				err = z.Fields[zkmr].DecodeMsg(dc)
				if err != nil {
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				return
			}
		}
	}
	if nextMiss6zyeg != -1 {
		dc.PopAlwaysNil()
	}

	if sawTopNil {
		dc.PopAlwaysNil()
	}

	if p, ok := interface{}(z).(msgp.PostLoad); ok {
		p.PostLoadHook()
	}

	return
}

// fields of Struct
var decodeMsgFieldOrder6zyeg = []string{"StructName__str", "Fields__slc"}

var decodeMsgFieldSkip6zyeg = []bool{false, false}

// fieldsNotEmpty supports omitempty tags
func (z *Struct) fieldsNotEmpty(isempty []bool) uint32 {
	return 2
}

// EncodeMsg implements msgp.Encodable
func (z *Struct) EncodeMsg(en *msgp.Writer) (err error) {
	if p, ok := interface{}(z).(msgp.PreSave); ok {
		p.PreSaveHook()
	}

	// map header, size 2
	// write "StructName__str"
	err = en.Append(0x82, 0xaf, 0x53, 0x74, 0x72, 0x75, 0x63, 0x74, 0x4e, 0x61, 0x6d, 0x65, 0x5f, 0x5f, 0x73, 0x74, 0x72)
	if err != nil {
		return err
	}
	err = en.WriteString(z.StructName)
	if err != nil {
		return
	}
	// write "Fields__slc"
	err = en.Append(0xab, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x73, 0x5f, 0x5f, 0x73, 0x6c, 0x63)
	if err != nil {
		return err
	}
	err = en.WriteArrayHeader(uint32(len(z.Fields)))
	if err != nil {
		return
	}
	for zkmr := range z.Fields {
		err = z.Fields[zkmr].EncodeMsg(en)
		if err != nil {
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Struct) MarshalMsg(b []byte) (o []byte, err error) {
	if p, ok := interface{}(z).(msgp.PreSave); ok {
		p.PreSaveHook()
	}

	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "StructName__str"
	o = append(o, 0x82, 0xaf, 0x53, 0x74, 0x72, 0x75, 0x63, 0x74, 0x4e, 0x61, 0x6d, 0x65, 0x5f, 0x5f, 0x73, 0x74, 0x72)
	o = msgp.AppendString(o, z.StructName)
	// string "Fields__slc"
	o = append(o, 0xab, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x73, 0x5f, 0x5f, 0x73, 0x6c, 0x63)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Fields)))
	for zkmr := range z.Fields {
		o, err = z.Fields[zkmr].MarshalMsg(o)
		if err != nil {
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Struct) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.UnmarshalMsgWithCfg(bts, nil)
}
func (z *Struct) UnmarshalMsgWithCfg(bts []byte, cfg *msgp.RuntimeConfig) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	nbs.Init(cfg)
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var field []byte
	_ = field
	const maxFields7zqyk = 2

	// -- templateUnmarshalMsg starts here--
	var totalEncodedFields7zqyk uint32
	if !nbs.AlwaysNil {
		totalEncodedFields7zqyk, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			return
		}
	}
	encodedFieldsLeft7zqyk := totalEncodedFields7zqyk
	missingFieldsLeft7zqyk := maxFields7zqyk - totalEncodedFields7zqyk

	var nextMiss7zqyk int32 = -1
	var found7zqyk [maxFields7zqyk]bool
	var curField7zqyk string

doneWithStruct7zqyk:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft7zqyk > 0 || missingFieldsLeft7zqyk > 0 {
		//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft7zqyk, missingFieldsLeft7zqyk, msgp.ShowFound(found7zqyk[:]), unmarshalMsgFieldOrder7zqyk)
		if encodedFieldsLeft7zqyk > 0 {
			encodedFieldsLeft7zqyk--
			field, bts, err = nbs.ReadMapKeyZC(bts)
			if err != nil {
				return
			}
			curField7zqyk = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss7zqyk < 0 {
				// set bts to contain just mnil (0xc0)
				bts = nbs.PushAlwaysNil(bts)
				nextMiss7zqyk = 0
			}
			for nextMiss7zqyk < maxFields7zqyk && (found7zqyk[nextMiss7zqyk] || unmarshalMsgFieldSkip7zqyk[nextMiss7zqyk]) {
				nextMiss7zqyk++
			}
			if nextMiss7zqyk == maxFields7zqyk {
				// filled all the empty fields!
				break doneWithStruct7zqyk
			}
			missingFieldsLeft7zqyk--
			curField7zqyk = unmarshalMsgFieldOrder7zqyk[nextMiss7zqyk]
		}
		//fmt.Printf("switching on curField: '%v'\n", curField7zqyk)
		switch curField7zqyk {
		// -- templateUnmarshalMsg ends here --

		case "StructName__str":
			found7zqyk[0] = true
			z.StructName, bts, err = nbs.ReadStringBytes(bts)

			if err != nil {
				return
			}
		case "Fields__slc":
			found7zqyk[1] = true
			if nbs.AlwaysNil {
				(z.Fields) = (z.Fields)[:0]
			} else {

				var zfxp uint32
				zfxp, bts, err = nbs.ReadArrayHeaderBytes(bts)
				if err != nil {
					return
				}
				if cap(z.Fields) >= int(zfxp) {
					z.Fields = (z.Fields)[:zfxp]
				} else {
					z.Fields = make([]Field, zfxp)
				}
				for zkmr := range z.Fields {
					bts, err = z.Fields[zkmr].UnmarshalMsg(bts)
					if err != nil {
						return
					}
					if err != nil {
						return
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				return
			}
		}
	}
	if nextMiss7zqyk != -1 {
		bts = nbs.PopAlwaysNil()
	}

	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	if p, ok := interface{}(z).(msgp.PostLoad); ok {
		p.PostLoadHook()
	}

	return
}

// fields of Struct
var unmarshalMsgFieldOrder7zqyk = []string{"StructName__str", "Fields__slc"}

var unmarshalMsgFieldSkip7zqyk = []bool{false, false}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Struct) Msgsize() (s int) {
	s = 1 + 16 + msgp.StringPrefixSize + len(z.StructName) + 12 + msgp.ArrayHeaderSize
	for zkmr := range z.Fields {
		s += z.Fields[zkmr].Msgsize()
	}
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *Zkind) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	{
		var zara uint64
		zara, err = dc.ReadUint64()
		(*z) = Zkind(zara)
	}
	if err != nil {
		return
	}
	if sawTopNil {
		dc.PopAlwaysNil()
	}

	if p, ok := interface{}(z).(msgp.PostLoad); ok {
		p.PostLoadHook()
	}

	return
}

// EncodeMsg implements msgp.Encodable
func (z Zkind) EncodeMsg(en *msgp.Writer) (err error) {
	if p, ok := interface{}(z).(msgp.PreSave); ok {
		p.PreSaveHook()
	}

	err = en.WriteUint64(uint64(z))
	if err != nil {
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z Zkind) MarshalMsg(b []byte) (o []byte, err error) {
	if p, ok := interface{}(z).(msgp.PreSave); ok {
		p.PreSaveHook()
	}

	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendUint64(o, uint64(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Zkind) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.UnmarshalMsgWithCfg(bts, nil)
}
func (z *Zkind) UnmarshalMsgWithCfg(bts []byte, cfg *msgp.RuntimeConfig) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	nbs.Init(cfg)
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	{
		var zmvw uint64
		zmvw, bts, err = nbs.ReadUint64Bytes(bts)

		if err != nil {
			return
		}
		(*z) = Zkind(zmvw)
	}
	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	if p, ok := interface{}(z).(msgp.PostLoad); ok {
		p.PostLoadHook()
	}

	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z Zkind) Msgsize() (s int) {
	s = msgp.Uint64Size
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *Ztype) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var field []byte
	_ = field
	const maxFields8zhjl = 4

	// -- templateDecodeMsg starts here--
	var totalEncodedFields8zhjl uint32
	totalEncodedFields8zhjl, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	encodedFieldsLeft8zhjl := totalEncodedFields8zhjl
	missingFieldsLeft8zhjl := maxFields8zhjl - totalEncodedFields8zhjl

	var nextMiss8zhjl int32 = -1
	var found8zhjl [maxFields8zhjl]bool
	var curField8zhjl string

doneWithStruct8zhjl:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft8zhjl > 0 || missingFieldsLeft8zhjl > 0 {
		//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft8zhjl, missingFieldsLeft8zhjl, msgp.ShowFound(found8zhjl[:]), decodeMsgFieldOrder8zhjl)
		if encodedFieldsLeft8zhjl > 0 {
			encodedFieldsLeft8zhjl--
			field, err = dc.ReadMapKeyPtr()
			if err != nil {
				return
			}
			curField8zhjl = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss8zhjl < 0 {
				// tell the reader to only give us Nils
				// until further notice.
				dc.PushAlwaysNil()
				nextMiss8zhjl = 0
			}
			for nextMiss8zhjl < maxFields8zhjl && (found8zhjl[nextMiss8zhjl] || decodeMsgFieldSkip8zhjl[nextMiss8zhjl]) {
				nextMiss8zhjl++
			}
			if nextMiss8zhjl == maxFields8zhjl {
				// filled all the empty fields!
				break doneWithStruct8zhjl
			}
			missingFieldsLeft8zhjl--
			curField8zhjl = decodeMsgFieldOrder8zhjl[nextMiss8zhjl]
		}
		//fmt.Printf("switching on curField: '%v'\n", curField8zhjl)
		switch curField8zhjl {
		// -- templateDecodeMsg ends here --

		case "Kind__":
			found8zhjl[0] = true
			{
				var zjhq uint64
				zjhq, err = dc.ReadUint64()
				z.Kind = Zkind(zjhq)
			}
			if err != nil {
				return
			}
		case "Str__str":
			found8zhjl[1] = true
			z.Str, err = dc.ReadString()
			if err != nil {
				return
			}
		case "Domain__ptr":
			found8zhjl[2] = true
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}

				if z.Domain != nil {
					dc.PushAlwaysNil()
					err = z.Domain.DecodeMsg(dc)
					if err != nil {
						return
					}
					dc.PopAlwaysNil()
				}
			} else {
				// not Nil, we have something to read

				if z.Domain == nil {
					z.Domain = new(Ztype)
				}
				err = z.Domain.DecodeMsg(dc)
				if err != nil {
					return
				}
			}
		case "Range__ptr":
			found8zhjl[3] = true
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}

				if z.Range != nil {
					dc.PushAlwaysNil()
					err = z.Range.DecodeMsg(dc)
					if err != nil {
						return
					}
					dc.PopAlwaysNil()
				}
			} else {
				// not Nil, we have something to read

				if z.Range == nil {
					z.Range = new(Ztype)
				}
				err = z.Range.DecodeMsg(dc)
				if err != nil {
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				return
			}
		}
	}
	if nextMiss8zhjl != -1 {
		dc.PopAlwaysNil()
	}

	if sawTopNil {
		dc.PopAlwaysNil()
	}

	if p, ok := interface{}(z).(msgp.PostLoad); ok {
		p.PostLoadHook()
	}

	return
}

// fields of Ztype
var decodeMsgFieldOrder8zhjl = []string{"Kind__", "Str__str", "Domain__ptr", "Range__ptr"}

var decodeMsgFieldSkip8zhjl = []bool{false, false, false, false}

// fieldsNotEmpty supports omitempty tags
func (z *Ztype) fieldsNotEmpty(isempty []bool) uint32 {
	if len(isempty) == 0 {
		return 4
	}
	var fieldsInUse uint32 = 4
	isempty[1] = (len(z.Str) == 0) // string, omitempty
	if isempty[1] {
		fieldsInUse--
	}
	isempty[2] = (z.Domain == nil) // pointer, omitempty
	if isempty[2] {
		fieldsInUse--
	}
	isempty[3] = (z.Range == nil) // pointer, omitempty
	if isempty[3] {
		fieldsInUse--
	}

	return fieldsInUse
}

// EncodeMsg implements msgp.Encodable
func (z *Ztype) EncodeMsg(en *msgp.Writer) (err error) {
	if p, ok := interface{}(z).(msgp.PreSave); ok {
		p.PreSaveHook()
	}

	// honor the omitempty tags
	var empty_zykt [4]bool
	fieldsInUse_zxes := z.fieldsNotEmpty(empty_zykt[:])

	// map header
	err = en.WriteMapHeader(fieldsInUse_zxes)
	if err != nil {
		return err
	}

	// write "Kind__"
	err = en.Append(0xa6, 0x4b, 0x69, 0x6e, 0x64, 0x5f, 0x5f)
	if err != nil {
		return err
	}
	err = en.WriteUint64(uint64(z.Kind))
	if err != nil {
		return
	}
	if !empty_zykt[1] {
		// write "Str__str"
		err = en.Append(0xa8, 0x53, 0x74, 0x72, 0x5f, 0x5f, 0x73, 0x74, 0x72)
		if err != nil {
			return err
		}
		err = en.WriteString(z.Str)
		if err != nil {
			return
		}
	}

	if !empty_zykt[2] {
		// write "Domain__ptr"
		err = en.Append(0xab, 0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x5f, 0x5f, 0x70, 0x74, 0x72)
		if err != nil {
			return err
		}
		if z.Domain == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.Domain.EncodeMsg(en)
			if err != nil {
				return
			}
		}
	}

	if !empty_zykt[3] {
		// write "Range__ptr"
		err = en.Append(0xaa, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x5f, 0x5f, 0x70, 0x74, 0x72)
		if err != nil {
			return err
		}
		if z.Range == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.Range.EncodeMsg(en)
			if err != nil {
				return
			}
		}
	}

	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Ztype) MarshalMsg(b []byte) (o []byte, err error) {
	if p, ok := interface{}(z).(msgp.PreSave); ok {
		p.PreSaveHook()
	}

	o = msgp.Require(b, z.Msgsize())

	// honor the omitempty tags
	var empty [4]bool
	fieldsInUse := z.fieldsNotEmpty(empty[:])
	o = msgp.AppendMapHeader(o, fieldsInUse)

	// string "Kind__"
	o = append(o, 0xa6, 0x4b, 0x69, 0x6e, 0x64, 0x5f, 0x5f)
	o = msgp.AppendUint64(o, uint64(z.Kind))
	if !empty[1] {
		// string "Str__str"
		o = append(o, 0xa8, 0x53, 0x74, 0x72, 0x5f, 0x5f, 0x73, 0x74, 0x72)
		o = msgp.AppendString(o, z.Str)
	}

	if !empty[2] {
		// string "Domain__ptr"
		o = append(o, 0xab, 0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x5f, 0x5f, 0x70, 0x74, 0x72)
		if z.Domain == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Domain.MarshalMsg(o)
			if err != nil {
				return
			}
		}
	}

	if !empty[3] {
		// string "Range__ptr"
		o = append(o, 0xaa, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x5f, 0x5f, 0x70, 0x74, 0x72)
		if z.Range == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Range.MarshalMsg(o)
			if err != nil {
				return
			}
		}
	}

	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Ztype) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.UnmarshalMsgWithCfg(bts, nil)
}
func (z *Ztype) UnmarshalMsgWithCfg(bts []byte, cfg *msgp.RuntimeConfig) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	nbs.Init(cfg)
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var field []byte
	_ = field
	const maxFields9zqvp = 4

	// -- templateUnmarshalMsg starts here--
	var totalEncodedFields9zqvp uint32
	if !nbs.AlwaysNil {
		totalEncodedFields9zqvp, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			return
		}
	}
	encodedFieldsLeft9zqvp := totalEncodedFields9zqvp
	missingFieldsLeft9zqvp := maxFields9zqvp - totalEncodedFields9zqvp

	var nextMiss9zqvp int32 = -1
	var found9zqvp [maxFields9zqvp]bool
	var curField9zqvp string

doneWithStruct9zqvp:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft9zqvp > 0 || missingFieldsLeft9zqvp > 0 {
		//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft9zqvp, missingFieldsLeft9zqvp, msgp.ShowFound(found9zqvp[:]), unmarshalMsgFieldOrder9zqvp)
		if encodedFieldsLeft9zqvp > 0 {
			encodedFieldsLeft9zqvp--
			field, bts, err = nbs.ReadMapKeyZC(bts)
			if err != nil {
				return
			}
			curField9zqvp = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss9zqvp < 0 {
				// set bts to contain just mnil (0xc0)
				bts = nbs.PushAlwaysNil(bts)
				nextMiss9zqvp = 0
			}
			for nextMiss9zqvp < maxFields9zqvp && (found9zqvp[nextMiss9zqvp] || unmarshalMsgFieldSkip9zqvp[nextMiss9zqvp]) {
				nextMiss9zqvp++
			}
			if nextMiss9zqvp == maxFields9zqvp {
				// filled all the empty fields!
				break doneWithStruct9zqvp
			}
			missingFieldsLeft9zqvp--
			curField9zqvp = unmarshalMsgFieldOrder9zqvp[nextMiss9zqvp]
		}
		//fmt.Printf("switching on curField: '%v'\n", curField9zqvp)
		switch curField9zqvp {
		// -- templateUnmarshalMsg ends here --

		case "Kind__":
			found9zqvp[0] = true
			{
				var ziji uint64
				ziji, bts, err = nbs.ReadUint64Bytes(bts)

				if err != nil {
					return
				}
				z.Kind = Zkind(ziji)
			}
		case "Str__str":
			found9zqvp[1] = true
			z.Str, bts, err = nbs.ReadStringBytes(bts)

			if err != nil {
				return
			}
		case "Domain__ptr":
			found9zqvp[2] = true
			if nbs.AlwaysNil {
				if z.Domain != nil {
					z.Domain.UnmarshalMsg(msgp.OnlyNilSlice)
				}
			} else {
				// not nbs.AlwaysNil
				if msgp.IsNil(bts) {
					bts = bts[1:]
					if nil != z.Domain {
						z.Domain.UnmarshalMsg(msgp.OnlyNilSlice)
					}
				} else {
					// not nbs.AlwaysNil and not IsNil(bts): have something to read

					if z.Domain == nil {
						z.Domain = new(Ztype)
					}
					bts, err = z.Domain.UnmarshalMsg(bts)
					if err != nil {
						return
					}
					if err != nil {
						return
					}
				}
			}
		case "Range__ptr":
			found9zqvp[3] = true
			if nbs.AlwaysNil {
				if z.Range != nil {
					z.Range.UnmarshalMsg(msgp.OnlyNilSlice)
				}
			} else {
				// not nbs.AlwaysNil
				if msgp.IsNil(bts) {
					bts = bts[1:]
					if nil != z.Range {
						z.Range.UnmarshalMsg(msgp.OnlyNilSlice)
					}
				} else {
					// not nbs.AlwaysNil and not IsNil(bts): have something to read

					if z.Range == nil {
						z.Range = new(Ztype)
					}
					bts, err = z.Range.UnmarshalMsg(bts)
					if err != nil {
						return
					}
					if err != nil {
						return
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				return
			}
		}
	}
	if nextMiss9zqvp != -1 {
		bts = nbs.PopAlwaysNil()
	}

	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	if p, ok := interface{}(z).(msgp.PostLoad); ok {
		p.PostLoadHook()
	}

	return
}

// fields of Ztype
var unmarshalMsgFieldOrder9zqvp = []string{"Kind__", "Str__str", "Domain__ptr", "Range__ptr"}

var unmarshalMsgFieldSkip9zqvp = []bool{false, false, false, false}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Ztype) Msgsize() (s int) {
	s = 1 + 7 + msgp.Uint64Size + 9 + msgp.StringPrefixSize + len(z.Str) + 12
	if z.Domain == nil {
		s += msgp.NilSize
	} else {
		s += z.Domain.Msgsize()
	}
	s += 11
	if z.Range == nil {
		s += msgp.NilSize
	} else {
		s += z.Range.Msgsize()
	}
	return
}

// FileZebra holds Greenpack schema from file 'zebra.go'
type FileZebra struct{}

// ZebraSchemaInMsgpack2Format provides the Greenpack Schema in msgpack2 format, length 5580 bytes
func (FileZebra) ZebraSchemaInMsgpack2Format() []byte {
	return []byte{
		0x85, 0xb4, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x50, 0x61,
		0x74, 0x68, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x73,
		0x74, 0x72, 0xa8, 0x7a, 0x65, 0x62, 0x72, 0x61, 0x2e, 0x67,
		0x6f, 0xb7, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x50, 0x61,
		0x63, 0x6b, 0x61, 0x67, 0x65, 0x5f, 0x7a, 0x69, 0x64, 0x2d,
		0x31, 0x5f, 0x73, 0x74, 0x72, 0xa5, 0x7a, 0x65, 0x62, 0x72,
		0x61, 0xb7, 0x5a, 0x65, 0x62, 0x72, 0x61, 0x53, 0x63, 0x68,
		0x65, 0x6d, 0x61, 0x49, 0x64, 0x5f, 0x7a, 0x69, 0x64, 0x2d,
		0x31, 0x5f, 0x69, 0x36, 0x34, 0xd3, 0x00, 0x01, 0xa5, 0xa9,
		0x4b, 0xd4, 0x96, 0x24, 0xb1, 0x53, 0x74, 0x72, 0x75, 0x63,
		0x74, 0x73, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x6d,
		0x61, 0x70, 0x84, 0xa5, 0x5a, 0x74, 0x79, 0x70, 0x65, 0x82,
		0xb4, 0x53, 0x74, 0x72, 0x75, 0x63, 0x74, 0x4e, 0x61, 0x6d,
		0x65, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x73, 0x74,
		0x72, 0xa5, 0x5a, 0x74, 0x79, 0x70, 0x65, 0xb0, 0x46, 0x69,
		0x65, 0x6c, 0x64, 0x73, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31,
		0x5f, 0x73, 0x6c, 0x63, 0x94, 0x87, 0xad, 0x5a, 0x69, 0x64,
		0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x69, 0x36, 0x34,
		0xff, 0xb5, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x47, 0x6f, 0x4e,
		0x61, 0x6d, 0x65, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f,
		0x73, 0x74, 0x72, 0xa4, 0x4b, 0x69, 0x6e, 0x64, 0xb6, 0x46,
		0x69, 0x65, 0x6c, 0x64, 0x54, 0x61, 0x67, 0x4e, 0x61, 0x6d,
		0x65, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x73, 0x74,
		0x72, 0xa4, 0x4b, 0x69, 0x6e, 0x64, 0xb6, 0x46, 0x69, 0x65,
		0x6c, 0x64, 0x54, 0x79, 0x70, 0x65, 0x53, 0x74, 0x72, 0x5f,
		0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x73, 0x74, 0x72, 0xa5,
		0x5a, 0x6b, 0x69, 0x6e, 0x64, 0xb4, 0x46, 0x69, 0x65, 0x6c,
		0x64, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x5f,
		0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x17, 0xb5, 0x46, 0x69,
		0x65, 0x6c, 0x64, 0x50, 0x72, 0x69, 0x6d, 0x69, 0x74, 0x69,
		0x76, 0x65, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x0b,
		0xb7, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x46, 0x75, 0x6c, 0x6c,
		0x54, 0x79, 0x70, 0x65, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31,
		0x5f, 0x70, 0x74, 0x72, 0x82, 0xab, 0x4b, 0x69, 0x6e, 0x64,
		0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x0b, 0xad, 0x53,
		0x74, 0x72, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x73,
		0x74, 0x72, 0xa6, 0x75, 0x69, 0x6e, 0x74, 0x36, 0x34, 0x88,
		0xad, 0x5a, 0x69, 0x64, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31,
		0x5f, 0x69, 0x36, 0x34, 0xff, 0xb5, 0x46, 0x69, 0x65, 0x6c,
		0x64, 0x47, 0x6f, 0x4e, 0x61, 0x6d, 0x65, 0x5f, 0x7a, 0x69,
		0x64, 0x2d, 0x31, 0x5f, 0x73, 0x74, 0x72, 0xa3, 0x53, 0x74,
		0x72, 0xb6, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x54, 0x61, 0x67,
		0x4e, 0x61, 0x6d, 0x65, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31,
		0x5f, 0x73, 0x74, 0x72, 0xa3, 0x53, 0x74, 0x72, 0xb6, 0x46,
		0x69, 0x65, 0x6c, 0x64, 0x54, 0x79, 0x70, 0x65, 0x53, 0x74,
		0x72, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x73, 0x74,
		0x72, 0xa6, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0xb4, 0x46,
		0x69, 0x65, 0x6c, 0x64, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f,
		0x72, 0x79, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x17,
		0xb5, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x50, 0x72, 0x69, 0x6d,
		0x69, 0x74, 0x69, 0x76, 0x65, 0x5f, 0x7a, 0x69, 0x64, 0x2d,
		0x31, 0x5f, 0x02, 0xb7, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x46,
		0x75, 0x6c, 0x6c, 0x54, 0x79, 0x70, 0x65, 0x5f, 0x7a, 0x69,
		0x64, 0x2d, 0x31, 0x5f, 0x70, 0x74, 0x72, 0x82, 0xab, 0x4b,
		0x69, 0x6e, 0x64, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f,
		0x02, 0xad, 0x53, 0x74, 0x72, 0x5f, 0x7a, 0x69, 0x64, 0x2d,
		0x31, 0x5f, 0x73, 0x74, 0x72, 0xa6, 0x73, 0x74, 0x72, 0x69,
		0x6e, 0x67, 0xb3, 0x4f, 0x6d, 0x69, 0x74, 0x45, 0x6d, 0x70,
		0x74, 0x79, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x62,
		0x6f, 0x6f, 0xc3, 0x87, 0xad, 0x5a, 0x69, 0x64, 0x5f, 0x7a,
		0x69, 0x64, 0x2d, 0x31, 0x5f, 0x69, 0x36, 0x34, 0xff, 0xb5,
		0x46, 0x69, 0x65, 0x6c, 0x64, 0x47, 0x6f, 0x4e, 0x61, 0x6d,
		0x65, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x73, 0x74,
		0x72, 0xa6, 0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0xb6, 0x46,
		0x69, 0x65, 0x6c, 0x64, 0x54, 0x61, 0x67, 0x4e, 0x61, 0x6d,
		0x65, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x73, 0x74,
		0x72, 0xa6, 0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0xb6, 0x46,
		0x69, 0x65, 0x6c, 0x64, 0x54, 0x79, 0x70, 0x65, 0x53, 0x74,
		0x72, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x73, 0x74,
		0x72, 0xa6, 0x2a, 0x5a, 0x74, 0x79, 0x70, 0x65, 0xb4, 0x46,
		0x69, 0x65, 0x6c, 0x64, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f,
		0x72, 0x79, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x1c,
		0xb7, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x46, 0x75, 0x6c, 0x6c,
		0x54, 0x79, 0x70, 0x65, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31,
		0x5f, 0x70, 0x74, 0x72, 0x83, 0xab, 0x4b, 0x69, 0x6e, 0x64,
		0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x1c, 0xad, 0x53,
		0x74, 0x72, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x73,
		0x74, 0x72, 0xa7, 0x50, 0x6f, 0x69, 0x6e, 0x74, 0x65, 0x72,
		0xb0, 0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x5f, 0x7a, 0x69,
		0x64, 0x2d, 0x31, 0x5f, 0x70, 0x74, 0x72, 0x82, 0xab, 0x4b,
		0x69, 0x6e, 0x64, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f,
		0x16, 0xad, 0x53, 0x74, 0x72, 0x5f, 0x7a, 0x69, 0x64, 0x2d,
		0x31, 0x5f, 0x73, 0x74, 0x72, 0xa5, 0x5a, 0x74, 0x79, 0x70,
		0x65, 0xb3, 0x4f, 0x6d, 0x69, 0x74, 0x45, 0x6d, 0x70, 0x74,
		0x79, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x62, 0x6f,
		0x6f, 0xc3, 0x87, 0xad, 0x5a, 0x69, 0x64, 0x5f, 0x7a, 0x69,
		0x64, 0x2d, 0x31, 0x5f, 0x69, 0x36, 0x34, 0xff, 0xb5, 0x46,
		0x69, 0x65, 0x6c, 0x64, 0x47, 0x6f, 0x4e, 0x61, 0x6d, 0x65,
		0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x73, 0x74, 0x72,
		0xa5, 0x52, 0x61, 0x6e, 0x67, 0x65, 0xb6, 0x46, 0x69, 0x65,
		0x6c, 0x64, 0x54, 0x61, 0x67, 0x4e, 0x61, 0x6d, 0x65, 0x5f,
		0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x73, 0x74, 0x72, 0xa5,
		0x52, 0x61, 0x6e, 0x67, 0x65, 0xb6, 0x46, 0x69, 0x65, 0x6c,
		0x64, 0x54, 0x79, 0x70, 0x65, 0x53, 0x74, 0x72, 0x5f, 0x7a,
		0x69, 0x64, 0x2d, 0x31, 0x5f, 0x73, 0x74, 0x72, 0xa6, 0x2a,
		0x5a, 0x74, 0x79, 0x70, 0x65, 0xb4, 0x46, 0x69, 0x65, 0x6c,
		0x64, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x5f,
		0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x1c, 0xb7, 0x46, 0x69,
		0x65, 0x6c, 0x64, 0x46, 0x75, 0x6c, 0x6c, 0x54, 0x79, 0x70,
		0x65, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x70, 0x74,
		0x72, 0x83, 0xab, 0x4b, 0x69, 0x6e, 0x64, 0x5f, 0x7a, 0x69,
		0x64, 0x2d, 0x31, 0x5f, 0x1c, 0xad, 0x53, 0x74, 0x72, 0x5f,
		0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x73, 0x74, 0x72, 0xa7,
		0x50, 0x6f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0xb0, 0x44, 0x6f,
		0x6d, 0x61, 0x69, 0x6e, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31,
		0x5f, 0x70, 0x74, 0x72, 0x82, 0xab, 0x4b, 0x69, 0x6e, 0x64,
		0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x16, 0xad, 0x53,
		0x74, 0x72, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x73,
		0x74, 0x72, 0xa5, 0x5a, 0x74, 0x79, 0x70, 0x65, 0xb3, 0x4f,
		0x6d, 0x69, 0x74, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x5f, 0x7a,
		0x69, 0x64, 0x2d, 0x31, 0x5f, 0x62, 0x6f, 0x6f, 0xc3, 0xa6,
		0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x82, 0xb4, 0x53, 0x74,
		0x72, 0x75, 0x63, 0x74, 0x4e, 0x61, 0x6d, 0x65, 0x5f, 0x7a,
		0x69, 0x64, 0x2d, 0x31, 0x5f, 0x73, 0x74, 0x72, 0xa6, 0x53,
		0x63, 0x68, 0x65, 0x6d, 0x61, 0xb0, 0x46, 0x69, 0x65, 0x6c,
		0x64, 0x73, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x73,
		0x6c, 0x63, 0x95, 0x87, 0xad, 0x5a, 0x69, 0x64, 0x5f, 0x7a,
		0x69, 0x64, 0x2d, 0x31, 0x5f, 0x69, 0x36, 0x34, 0xff, 0xb5,
		0x46, 0x69, 0x65, 0x6c, 0x64, 0x47, 0x6f, 0x4e, 0x61, 0x6d,
		0x65, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x73, 0x74,
		0x72, 0xaa, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x50, 0x61,
		0x74, 0x68, 0xb6, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x54, 0x61,
		0x67, 0x4e, 0x61, 0x6d, 0x65, 0x5f, 0x7a, 0x69, 0x64, 0x2d,
		0x31, 0x5f, 0x73, 0x74, 0x72, 0xaa, 0x53, 0x6f, 0x75, 0x72,
		0x63, 0x65, 0x50, 0x61, 0x74, 0x68, 0xb6, 0x46, 0x69, 0x65,
		0x6c, 0x64, 0x54, 0x79, 0x70, 0x65, 0x53, 0x74, 0x72, 0x5f,
		0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x73, 0x74, 0x72, 0xa6,
		0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0xb4, 0x46, 0x69, 0x65,
		0x6c, 0x64, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79,
		0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x17, 0xb5, 0x46,
		0x69, 0x65, 0x6c, 0x64, 0x50, 0x72, 0x69, 0x6d, 0x69, 0x74,
		0x69, 0x76, 0x65, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f,
		0x02, 0xb7, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x46, 0x75, 0x6c,
		0x6c, 0x54, 0x79, 0x70, 0x65, 0x5f, 0x7a, 0x69, 0x64, 0x2d,
		0x31, 0x5f, 0x70, 0x74, 0x72, 0x82, 0xab, 0x4b, 0x69, 0x6e,
		0x64, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x02, 0xad,
		0x53, 0x74, 0x72, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f,
		0x73, 0x74, 0x72, 0xa6, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67,
		0x87, 0xad, 0x5a, 0x69, 0x64, 0x5f, 0x7a, 0x69, 0x64, 0x2d,
		0x31, 0x5f, 0x69, 0x36, 0x34, 0xff, 0xb5, 0x46, 0x69, 0x65,
		0x6c, 0x64, 0x47, 0x6f, 0x4e, 0x61, 0x6d, 0x65, 0x5f, 0x7a,
		0x69, 0x64, 0x2d, 0x31, 0x5f, 0x73, 0x74, 0x72, 0xad, 0x53,
		0x6f, 0x75, 0x72, 0x63, 0x65, 0x50, 0x61, 0x63, 0x6b, 0x61,
		0x67, 0x65, 0xb6, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x54, 0x61,
		0x67, 0x4e, 0x61, 0x6d, 0x65, 0x5f, 0x7a, 0x69, 0x64, 0x2d,
		0x31, 0x5f, 0x73, 0x74, 0x72, 0xad, 0x53, 0x6f, 0x75, 0x72,
		0x63, 0x65, 0x50, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65, 0xb6,
		0x46, 0x69, 0x65, 0x6c, 0x64, 0x54, 0x79, 0x70, 0x65, 0x53,
		0x74, 0x72, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x73,
		0x74, 0x72, 0xa6, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0xb4,
		0x46, 0x69, 0x65, 0x6c, 0x64, 0x43, 0x61, 0x74, 0x65, 0x67,
		0x6f, 0x72, 0x79, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f,
		0x17, 0xb5, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x50, 0x72, 0x69,
		0x6d, 0x69, 0x74, 0x69, 0x76, 0x65, 0x5f, 0x7a, 0x69, 0x64,
		0x2d, 0x31, 0x5f, 0x02, 0xb7, 0x46, 0x69, 0x65, 0x6c, 0x64,
		0x46, 0x75, 0x6c, 0x6c, 0x54, 0x79, 0x70, 0x65, 0x5f, 0x7a,
		0x69, 0x64, 0x2d, 0x31, 0x5f, 0x70, 0x74, 0x72, 0x82, 0xab,
		0x4b, 0x69, 0x6e, 0x64, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31,
		0x5f, 0x02, 0xad, 0x53, 0x74, 0x72, 0x5f, 0x7a, 0x69, 0x64,
		0x2d, 0x31, 0x5f, 0x73, 0x74, 0x72, 0xa6, 0x73, 0x74, 0x72,
		0x69, 0x6e, 0x67, 0x87, 0xad, 0x5a, 0x69, 0x64, 0x5f, 0x7a,
		0x69, 0x64, 0x2d, 0x31, 0x5f, 0x69, 0x36, 0x34, 0xff, 0xb5,
		0x46, 0x69, 0x65, 0x6c, 0x64, 0x47, 0x6f, 0x4e, 0x61, 0x6d,
		0x65, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x73, 0x74,
		0x72, 0xad, 0x5a, 0x65, 0x62, 0x72, 0x61, 0x53, 0x63, 0x68,
		0x65, 0x6d, 0x61, 0x49, 0x64, 0xb6, 0x46, 0x69, 0x65, 0x6c,
		0x64, 0x54, 0x61, 0x67, 0x4e, 0x61, 0x6d, 0x65, 0x5f, 0x7a,
		0x69, 0x64, 0x2d, 0x31, 0x5f, 0x73, 0x74, 0x72, 0xad, 0x5a,
		0x65, 0x62, 0x72, 0x61, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61,
		0x49, 0x64, 0xb6, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x54, 0x79,
		0x70, 0x65, 0x53, 0x74, 0x72, 0x5f, 0x7a, 0x69, 0x64, 0x2d,
		0x31, 0x5f, 0x73, 0x74, 0x72, 0xa5, 0x69, 0x6e, 0x74, 0x36,
		0x34, 0xb4, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x43, 0x61, 0x74,
		0x65, 0x67, 0x6f, 0x72, 0x79, 0x5f, 0x7a, 0x69, 0x64, 0x2d,
		0x31, 0x5f, 0x17, 0xb5, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x50,
		0x72, 0x69, 0x6d, 0x69, 0x74, 0x69, 0x76, 0x65, 0x5f, 0x7a,
		0x69, 0x64, 0x2d, 0x31, 0x5f, 0x11, 0xb7, 0x46, 0x69, 0x65,
		0x6c, 0x64, 0x46, 0x75, 0x6c, 0x6c, 0x54, 0x79, 0x70, 0x65,
		0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x70, 0x74, 0x72,
		0x82, 0xab, 0x4b, 0x69, 0x6e, 0x64, 0x5f, 0x7a, 0x69, 0x64,
		0x2d, 0x31, 0x5f, 0x11, 0xad, 0x53, 0x74, 0x72, 0x5f, 0x7a,
		0x69, 0x64, 0x2d, 0x31, 0x5f, 0x73, 0x74, 0x72, 0xa5, 0x69,
		0x6e, 0x74, 0x36, 0x34, 0x86, 0xad, 0x5a, 0x69, 0x64, 0x5f,
		0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x69, 0x36, 0x34, 0xff,
		0xb5, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x47, 0x6f, 0x4e, 0x61,
		0x6d, 0x65, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x73,
		0x74, 0x72, 0xa7, 0x53, 0x74, 0x72, 0x75, 0x63, 0x74, 0x73,
		0xb6, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x54, 0x61, 0x67, 0x4e,
		0x61, 0x6d, 0x65, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f,
		0x73, 0x74, 0x72, 0xa7, 0x53, 0x74, 0x72, 0x75, 0x63, 0x74,
		0x73, 0xb6, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x54, 0x79, 0x70,
		0x65, 0x53, 0x74, 0x72, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31,
		0x5f, 0x73, 0x74, 0x72, 0xb2, 0x6d, 0x61, 0x70, 0x5b, 0x73,
		0x74, 0x72, 0x69, 0x6e, 0x67, 0x5d, 0x2a, 0x53, 0x74, 0x72,
		0x75, 0x63, 0x74, 0xb4, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x43,
		0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x5f, 0x7a, 0x69,
		0x64, 0x2d, 0x31, 0x5f, 0x18, 0xb7, 0x46, 0x69, 0x65, 0x6c,
		0x64, 0x46, 0x75, 0x6c, 0x6c, 0x54, 0x79, 0x70, 0x65, 0x5f,
		0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x70, 0x74, 0x72, 0x84,
		0xab, 0x4b, 0x69, 0x6e, 0x64, 0x5f, 0x7a, 0x69, 0x64, 0x2d,
		0x31, 0x5f, 0x18, 0xad, 0x53, 0x74, 0x72, 0x5f, 0x7a, 0x69,
		0x64, 0x2d, 0x31, 0x5f, 0x73, 0x74, 0x72, 0xa3, 0x4d, 0x61,
		0x70, 0xb0, 0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x5f, 0x7a,
		0x69, 0x64, 0x2d, 0x31, 0x5f, 0x70, 0x74, 0x72, 0x82, 0xab,
		0x4b, 0x69, 0x6e, 0x64, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31,
		0x5f, 0x02, 0xad, 0x53, 0x74, 0x72, 0x5f, 0x7a, 0x69, 0x64,
		0x2d, 0x31, 0x5f, 0x73, 0x74, 0x72, 0xa6, 0x73, 0x74, 0x72,
		0x69, 0x6e, 0x67, 0xaf, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x5f,
		0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x70, 0x74, 0x72, 0x83,
		0xab, 0x4b, 0x69, 0x6e, 0x64, 0x5f, 0x7a, 0x69, 0x64, 0x2d,
		0x31, 0x5f, 0x1c, 0xad, 0x53, 0x74, 0x72, 0x5f, 0x7a, 0x69,
		0x64, 0x2d, 0x31, 0x5f, 0x73, 0x74, 0x72, 0xa7, 0x50, 0x6f,
		0x69, 0x6e, 0x74, 0x65, 0x72, 0xb0, 0x44, 0x6f, 0x6d, 0x61,
		0x69, 0x6e, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x70,
		0x74, 0x72, 0x82, 0xab, 0x4b, 0x69, 0x6e, 0x64, 0x5f, 0x7a,
		0x69, 0x64, 0x2d, 0x31, 0x5f, 0x19, 0xad, 0x53, 0x74, 0x72,
		0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x73, 0x74, 0x72,
		0xa6, 0x53, 0x74, 0x72, 0x75, 0x63, 0x74, 0x86, 0xad, 0x5a,
		0x69, 0x64, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x69,
		0x36, 0x34, 0xff, 0xb5, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x47,
		0x6f, 0x4e, 0x61, 0x6d, 0x65, 0x5f, 0x7a, 0x69, 0x64, 0x2d,
		0x31, 0x5f, 0x73, 0x74, 0x72, 0xa7, 0x49, 0x6d, 0x70, 0x6f,
		0x72, 0x74, 0x73, 0xb6, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x54,
		0x61, 0x67, 0x4e, 0x61, 0x6d, 0x65, 0x5f, 0x7a, 0x69, 0x64,
		0x2d, 0x31, 0x5f, 0x73, 0x74, 0x72, 0xa7, 0x49, 0x6d, 0x70,
		0x6f, 0x72, 0x74, 0x73, 0xb6, 0x46, 0x69, 0x65, 0x6c, 0x64,
		0x54, 0x79, 0x70, 0x65, 0x53, 0x74, 0x72, 0x5f, 0x7a, 0x69,
		0x64, 0x2d, 0x31, 0x5f, 0x73, 0x74, 0x72, 0xa8, 0x5b, 0x5d,
		0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0xb4, 0x46, 0x69, 0x65,
		0x6c, 0x64, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79,
		0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x1a, 0xb7, 0x46,
		0x69, 0x65, 0x6c, 0x64, 0x46, 0x75, 0x6c, 0x6c, 0x54, 0x79,
		0x70, 0x65, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x70,
		0x74, 0x72, 0x83, 0xab, 0x4b, 0x69, 0x6e, 0x64, 0x5f, 0x7a,
		0x69, 0x64, 0x2d, 0x31, 0x5f, 0x1a, 0xad, 0x53, 0x74, 0x72,
		0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x73, 0x74, 0x72,
		0xa5, 0x53, 0x6c, 0x69, 0x63, 0x65, 0xb0, 0x44, 0x6f, 0x6d,
		0x61, 0x69, 0x6e, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f,
		0x70, 0x74, 0x72, 0x82, 0xab, 0x4b, 0x69, 0x6e, 0x64, 0x5f,
		0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x02, 0xad, 0x53, 0x74,
		0x72, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x73, 0x74,
		0x72, 0xa6, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0xa6, 0x53,
		0x74, 0x72, 0x75, 0x63, 0x74, 0x82, 0xb4, 0x53, 0x74, 0x72,
		0x75, 0x63, 0x74, 0x4e, 0x61, 0x6d, 0x65, 0x5f, 0x7a, 0x69,
		0x64, 0x2d, 0x31, 0x5f, 0x73, 0x74, 0x72, 0xa6, 0x53, 0x74,
		0x72, 0x75, 0x63, 0x74, 0xb0, 0x46, 0x69, 0x65, 0x6c, 0x64,
		0x73, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x73, 0x6c,
		0x63, 0x92, 0x87, 0xad, 0x5a, 0x69, 0x64, 0x5f, 0x7a, 0x69,
		0x64, 0x2d, 0x31, 0x5f, 0x69, 0x36, 0x34, 0xff, 0xb5, 0x46,
		0x69, 0x65, 0x6c, 0x64, 0x47, 0x6f, 0x4e, 0x61, 0x6d, 0x65,
		0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x73, 0x74, 0x72,
		0xaa, 0x53, 0x74, 0x72, 0x75, 0x63, 0x74, 0x4e, 0x61, 0x6d,
		0x65, 0xb6, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x54, 0x61, 0x67,
		0x4e, 0x61, 0x6d, 0x65, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31,
		0x5f, 0x73, 0x74, 0x72, 0xaa, 0x53, 0x74, 0x72, 0x75, 0x63,
		0x74, 0x4e, 0x61, 0x6d, 0x65, 0xb6, 0x46, 0x69, 0x65, 0x6c,
		0x64, 0x54, 0x79, 0x70, 0x65, 0x53, 0x74, 0x72, 0x5f, 0x7a,
		0x69, 0x64, 0x2d, 0x31, 0x5f, 0x73, 0x74, 0x72, 0xa6, 0x73,
		0x74, 0x72, 0x69, 0x6e, 0x67, 0xb4, 0x46, 0x69, 0x65, 0x6c,
		0x64, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x5f,
		0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x17, 0xb5, 0x46, 0x69,
		0x65, 0x6c, 0x64, 0x50, 0x72, 0x69, 0x6d, 0x69, 0x74, 0x69,
		0x76, 0x65, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x02,
		0xb7, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x46, 0x75, 0x6c, 0x6c,
		0x54, 0x79, 0x70, 0x65, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31,
		0x5f, 0x70, 0x74, 0x72, 0x82, 0xab, 0x4b, 0x69, 0x6e, 0x64,
		0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x02, 0xad, 0x53,
		0x74, 0x72, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x73,
		0x74, 0x72, 0xa6, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x86,
		0xad, 0x5a, 0x69, 0x64, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31,
		0x5f, 0x69, 0x36, 0x34, 0xff, 0xb5, 0x46, 0x69, 0x65, 0x6c,
		0x64, 0x47, 0x6f, 0x4e, 0x61, 0x6d, 0x65, 0x5f, 0x7a, 0x69,
		0x64, 0x2d, 0x31, 0x5f, 0x73, 0x74, 0x72, 0xa6, 0x46, 0x69,
		0x65, 0x6c, 0x64, 0x73, 0xb6, 0x46, 0x69, 0x65, 0x6c, 0x64,
		0x54, 0x61, 0x67, 0x4e, 0x61, 0x6d, 0x65, 0x5f, 0x7a, 0x69,
		0x64, 0x2d, 0x31, 0x5f, 0x73, 0x74, 0x72, 0xa6, 0x46, 0x69,
		0x65, 0x6c, 0x64, 0x73, 0xb6, 0x46, 0x69, 0x65, 0x6c, 0x64,
		0x54, 0x79, 0x70, 0x65, 0x53, 0x74, 0x72, 0x5f, 0x7a, 0x69,
		0x64, 0x2d, 0x31, 0x5f, 0x73, 0x74, 0x72, 0xa7, 0x5b, 0x5d,
		0x46, 0x69, 0x65, 0x6c, 0x64, 0xb4, 0x46, 0x69, 0x65, 0x6c,
		0x64, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x5f,
		0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x1a, 0xb7, 0x46, 0x69,
		0x65, 0x6c, 0x64, 0x46, 0x75, 0x6c, 0x6c, 0x54, 0x79, 0x70,
		0x65, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x70, 0x74,
		0x72, 0x83, 0xab, 0x4b, 0x69, 0x6e, 0x64, 0x5f, 0x7a, 0x69,
		0x64, 0x2d, 0x31, 0x5f, 0x1a, 0xad, 0x53, 0x74, 0x72, 0x5f,
		0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x73, 0x74, 0x72, 0xa5,
		0x53, 0x6c, 0x69, 0x63, 0x65, 0xb0, 0x44, 0x6f, 0x6d, 0x61,
		0x69, 0x6e, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x70,
		0x74, 0x72, 0x82, 0xab, 0x4b, 0x69, 0x6e, 0x64, 0x5f, 0x7a,
		0x69, 0x64, 0x2d, 0x31, 0x5f, 0x16, 0xad, 0x53, 0x74, 0x72,
		0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x73, 0x74, 0x72,
		0xa5, 0x46, 0x69, 0x65, 0x6c, 0x64, 0xa5, 0x46, 0x69, 0x65,
		0x6c, 0x64, 0x82, 0xb4, 0x53, 0x74, 0x72, 0x75, 0x63, 0x74,
		0x4e, 0x61, 0x6d, 0x65, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31,
		0x5f, 0x73, 0x74, 0x72, 0xa5, 0x46, 0x69, 0x65, 0x6c, 0x64,
		0xb0, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x73, 0x5f, 0x7a, 0x69,
		0x64, 0x2d, 0x31, 0x5f, 0x73, 0x6c, 0x63, 0x9b, 0x87, 0xad,
		0x5a, 0x69, 0x64, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f,
		0x69, 0x36, 0x34, 0xff, 0xb5, 0x46, 0x69, 0x65, 0x6c, 0x64,
		0x47, 0x6f, 0x4e, 0x61, 0x6d, 0x65, 0x5f, 0x7a, 0x69, 0x64,
		0x2d, 0x31, 0x5f, 0x73, 0x74, 0x72, 0xa3, 0x5a, 0x69, 0x64,
		0xb6, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x54, 0x61, 0x67, 0x4e,
		0x61, 0x6d, 0x65, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f,
		0x73, 0x74, 0x72, 0xa3, 0x5a, 0x69, 0x64, 0xb6, 0x46, 0x69,
		0x65, 0x6c, 0x64, 0x54, 0x79, 0x70, 0x65, 0x53, 0x74, 0x72,
		0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x73, 0x74, 0x72,
		0xa5, 0x69, 0x6e, 0x74, 0x36, 0x34, 0xb4, 0x46, 0x69, 0x65,
		0x6c, 0x64, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79,
		0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x17, 0xb5, 0x46,
		0x69, 0x65, 0x6c, 0x64, 0x50, 0x72, 0x69, 0x6d, 0x69, 0x74,
		0x69, 0x76, 0x65, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f,
		0x11, 0xb7, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x46, 0x75, 0x6c,
		0x6c, 0x54, 0x79, 0x70, 0x65, 0x5f, 0x7a, 0x69, 0x64, 0x2d,
		0x31, 0x5f, 0x70, 0x74, 0x72, 0x82, 0xab, 0x4b, 0x69, 0x6e,
		0x64, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x11, 0xad,
		0x53, 0x74, 0x72, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f,
		0x73, 0x74, 0x72, 0xa5, 0x69, 0x6e, 0x74, 0x36, 0x34, 0x87,
		0xad, 0x5a, 0x69, 0x64, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31,
		0x5f, 0x69, 0x36, 0x34, 0xff, 0xb5, 0x46, 0x69, 0x65, 0x6c,
		0x64, 0x47, 0x6f, 0x4e, 0x61, 0x6d, 0x65, 0x5f, 0x7a, 0x69,
		0x64, 0x2d, 0x31, 0x5f, 0x73, 0x74, 0x72, 0xab, 0x46, 0x69,
		0x65, 0x6c, 0x64, 0x47, 0x6f, 0x4e, 0x61, 0x6d, 0x65, 0xb6,
		0x46, 0x69, 0x65, 0x6c, 0x64, 0x54, 0x61, 0x67, 0x4e, 0x61,
		0x6d, 0x65, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x73,
		0x74, 0x72, 0xab, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x47, 0x6f,
		0x4e, 0x61, 0x6d, 0x65, 0xb6, 0x46, 0x69, 0x65, 0x6c, 0x64,
		0x54, 0x79, 0x70, 0x65, 0x53, 0x74, 0x72, 0x5f, 0x7a, 0x69,
		0x64, 0x2d, 0x31, 0x5f, 0x73, 0x74, 0x72, 0xa6, 0x73, 0x74,
		0x72, 0x69, 0x6e, 0x67, 0xb4, 0x46, 0x69, 0x65, 0x6c, 0x64,
		0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x5f, 0x7a,
		0x69, 0x64, 0x2d, 0x31, 0x5f, 0x17, 0xb5, 0x46, 0x69, 0x65,
		0x6c, 0x64, 0x50, 0x72, 0x69, 0x6d, 0x69, 0x74, 0x69, 0x76,
		0x65, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x02, 0xb7,
		0x46, 0x69, 0x65, 0x6c, 0x64, 0x46, 0x75, 0x6c, 0x6c, 0x54,
		0x79, 0x70, 0x65, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f,
		0x70, 0x74, 0x72, 0x82, 0xab, 0x4b, 0x69, 0x6e, 0x64, 0x5f,
		0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x02, 0xad, 0x53, 0x74,
		0x72, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x73, 0x74,
		0x72, 0xa6, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x88, 0xad,
		0x5a, 0x69, 0x64, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f,
		0x69, 0x36, 0x34, 0xff, 0xb5, 0x46, 0x69, 0x65, 0x6c, 0x64,
		0x47, 0x6f, 0x4e, 0x61, 0x6d, 0x65, 0x5f, 0x7a, 0x69, 0x64,
		0x2d, 0x31, 0x5f, 0x73, 0x74, 0x72, 0xac, 0x46, 0x69, 0x65,
		0x6c, 0x64, 0x54, 0x61, 0x67, 0x4e, 0x61, 0x6d, 0x65, 0xb6,
		0x46, 0x69, 0x65, 0x6c, 0x64, 0x54, 0x61, 0x67, 0x4e, 0x61,
		0x6d, 0x65, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x73,
		0x74, 0x72, 0xac, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x54, 0x61,
		0x67, 0x4e, 0x61, 0x6d, 0x65, 0xb6, 0x46, 0x69, 0x65, 0x6c,
		0x64, 0x54, 0x79, 0x70, 0x65, 0x53, 0x74, 0x72, 0x5f, 0x7a,
		0x69, 0x64, 0x2d, 0x31, 0x5f, 0x73, 0x74, 0x72, 0xa6, 0x73,
		0x74, 0x72, 0x69, 0x6e, 0x67, 0xb4, 0x46, 0x69, 0x65, 0x6c,
		0x64, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x5f,
		0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x17, 0xb5, 0x46, 0x69,
		0x65, 0x6c, 0x64, 0x50, 0x72, 0x69, 0x6d, 0x69, 0x74, 0x69,
		0x76, 0x65, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x02,
		0xb7, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x46, 0x75, 0x6c, 0x6c,
		0x54, 0x79, 0x70, 0x65, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31,
		0x5f, 0x70, 0x74, 0x72, 0x82, 0xab, 0x4b, 0x69, 0x6e, 0x64,
		0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x02, 0xad, 0x53,
		0x74, 0x72, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x73,
		0x74, 0x72, 0xa6, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0xb3,
		0x4f, 0x6d, 0x69, 0x74, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x5f,
		0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x62, 0x6f, 0x6f, 0xc3,
		0x88, 0xad, 0x5a, 0x69, 0x64, 0x5f, 0x7a, 0x69, 0x64, 0x2d,
		0x31, 0x5f, 0x69, 0x36, 0x34, 0xff, 0xb5, 0x46, 0x69, 0x65,
		0x6c, 0x64, 0x47, 0x6f, 0x4e, 0x61, 0x6d, 0x65, 0x5f, 0x7a,
		0x69, 0x64, 0x2d, 0x31, 0x5f, 0x73, 0x74, 0x72, 0xac, 0x46,
		0x69, 0x65, 0x6c, 0x64, 0x54, 0x79, 0x70, 0x65, 0x53, 0x74,
		0x72, 0xb6, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x54, 0x61, 0x67,
		0x4e, 0x61, 0x6d, 0x65, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31,
		0x5f, 0x73, 0x74, 0x72, 0xac, 0x46, 0x69, 0x65, 0x6c, 0x64,
		0x54, 0x79, 0x70, 0x65, 0x53, 0x74, 0x72, 0xb6, 0x46, 0x69,
		0x65, 0x6c, 0x64, 0x54, 0x79, 0x70, 0x65, 0x53, 0x74, 0x72,
		0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x73, 0x74, 0x72,
		0xa6, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0xb4, 0x46, 0x69,
		0x65, 0x6c, 0x64, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72,
		0x79, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x17, 0xb5,
		0x46, 0x69, 0x65, 0x6c, 0x64, 0x50, 0x72, 0x69, 0x6d, 0x69,
		0x74, 0x69, 0x76, 0x65, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31,
		0x5f, 0x02, 0xb7, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x46, 0x75,
		0x6c, 0x6c, 0x54, 0x79, 0x70, 0x65, 0x5f, 0x7a, 0x69, 0x64,
		0x2d, 0x31, 0x5f, 0x70, 0x74, 0x72, 0x82, 0xab, 0x4b, 0x69,
		0x6e, 0x64, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x02,
		0xad, 0x53, 0x74, 0x72, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31,
		0x5f, 0x73, 0x74, 0x72, 0xa6, 0x73, 0x74, 0x72, 0x69, 0x6e,
		0x67, 0xb3, 0x4f, 0x6d, 0x69, 0x74, 0x45, 0x6d, 0x70, 0x74,
		0x79, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x62, 0x6f,
		0x6f, 0xc3, 0x88, 0xad, 0x5a, 0x69, 0x64, 0x5f, 0x7a, 0x69,
		0x64, 0x2d, 0x31, 0x5f, 0x69, 0x36, 0x34, 0xff, 0xb5, 0x46,
		0x69, 0x65, 0x6c, 0x64, 0x47, 0x6f, 0x4e, 0x61, 0x6d, 0x65,
		0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x73, 0x74, 0x72,
		0xad, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x43, 0x61, 0x74, 0x65,
		0x67, 0x6f, 0x72, 0x79, 0xb6, 0x46, 0x69, 0x65, 0x6c, 0x64,
		0x54, 0x61, 0x67, 0x4e, 0x61, 0x6d, 0x65, 0x5f, 0x7a, 0x69,
		0x64, 0x2d, 0x31, 0x5f, 0x73, 0x74, 0x72, 0xad, 0x46, 0x69,
		0x65, 0x6c, 0x64, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72,
		0x79, 0xb6, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x54, 0x79, 0x70,
		0x65, 0x53, 0x74, 0x72, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31,
		0x5f, 0x73, 0x74, 0x72, 0xa5, 0x5a, 0x6b, 0x69, 0x6e, 0x64,
		0xb4, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x43, 0x61, 0x74, 0x65,
		0x67, 0x6f, 0x72, 0x79, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31,
		0x5f, 0x17, 0xb5, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x50, 0x72,
		0x69, 0x6d, 0x69, 0x74, 0x69, 0x76, 0x65, 0x5f, 0x7a, 0x69,
		0x64, 0x2d, 0x31, 0x5f, 0x0b, 0xb7, 0x46, 0x69, 0x65, 0x6c,
		0x64, 0x46, 0x75, 0x6c, 0x6c, 0x54, 0x79, 0x70, 0x65, 0x5f,
		0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x70, 0x74, 0x72, 0x82,
		0xab, 0x4b, 0x69, 0x6e, 0x64, 0x5f, 0x7a, 0x69, 0x64, 0x2d,
		0x31, 0x5f, 0x0b, 0xad, 0x53, 0x74, 0x72, 0x5f, 0x7a, 0x69,
		0x64, 0x2d, 0x31, 0x5f, 0x73, 0x74, 0x72, 0xa6, 0x75, 0x69,
		0x6e, 0x74, 0x36, 0x34, 0xb3, 0x4f, 0x6d, 0x69, 0x74, 0x45,
		0x6d, 0x70, 0x74, 0x79, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31,
		0x5f, 0x62, 0x6f, 0x6f, 0xc3, 0x88, 0xad, 0x5a, 0x69, 0x64,
		0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x69, 0x36, 0x34,
		0xff, 0xb5, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x47, 0x6f, 0x4e,
		0x61, 0x6d, 0x65, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f,
		0x73, 0x74, 0x72, 0xae, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x50,
		0x72, 0x69, 0x6d, 0x69, 0x74, 0x69, 0x76, 0x65, 0xb6, 0x46,
		0x69, 0x65, 0x6c, 0x64, 0x54, 0x61, 0x67, 0x4e, 0x61, 0x6d,
		0x65, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x73, 0x74,
		0x72, 0xae, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x50, 0x72, 0x69,
		0x6d, 0x69, 0x74, 0x69, 0x76, 0x65, 0xb6, 0x46, 0x69, 0x65,
		0x6c, 0x64, 0x54, 0x79, 0x70, 0x65, 0x53, 0x74, 0x72, 0x5f,
		0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x73, 0x74, 0x72, 0xa5,
		0x5a, 0x6b, 0x69, 0x6e, 0x64, 0xb4, 0x46, 0x69, 0x65, 0x6c,
		0x64, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x5f,
		0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x17, 0xb5, 0x46, 0x69,
		0x65, 0x6c, 0x64, 0x50, 0x72, 0x69, 0x6d, 0x69, 0x74, 0x69,
		0x76, 0x65, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x0b,
		0xb7, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x46, 0x75, 0x6c, 0x6c,
		0x54, 0x79, 0x70, 0x65, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31,
		0x5f, 0x70, 0x74, 0x72, 0x82, 0xab, 0x4b, 0x69, 0x6e, 0x64,
		0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x0b, 0xad, 0x53,
		0x74, 0x72, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x73,
		0x74, 0x72, 0xa6, 0x75, 0x69, 0x6e, 0x74, 0x36, 0x34, 0xb3,
		0x4f, 0x6d, 0x69, 0x74, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x5f,
		0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x62, 0x6f, 0x6f, 0xc3,
		0x87, 0xad, 0x5a, 0x69, 0x64, 0x5f, 0x7a, 0x69, 0x64, 0x2d,
		0x31, 0x5f, 0x69, 0x36, 0x34, 0xff, 0xb5, 0x46, 0x69, 0x65,
		0x6c, 0x64, 0x47, 0x6f, 0x4e, 0x61, 0x6d, 0x65, 0x5f, 0x7a,
		0x69, 0x64, 0x2d, 0x31, 0x5f, 0x73, 0x74, 0x72, 0xad, 0x46,
		0x69, 0x65, 0x6c, 0x64, 0x46, 0x75, 0x6c, 0x6c, 0x54, 0x79,
		0x70, 0x65, 0xb6, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x54, 0x61,
		0x67, 0x4e, 0x61, 0x6d, 0x65, 0x5f, 0x7a, 0x69, 0x64, 0x2d,
		0x31, 0x5f, 0x73, 0x74, 0x72, 0xad, 0x46, 0x69, 0x65, 0x6c,
		0x64, 0x46, 0x75, 0x6c, 0x6c, 0x54, 0x79, 0x70, 0x65, 0xb6,
		0x46, 0x69, 0x65, 0x6c, 0x64, 0x54, 0x79, 0x70, 0x65, 0x53,
		0x74, 0x72, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x73,
		0x74, 0x72, 0xa6, 0x2a, 0x5a, 0x74, 0x79, 0x70, 0x65, 0xb4,
		0x46, 0x69, 0x65, 0x6c, 0x64, 0x43, 0x61, 0x74, 0x65, 0x67,
		0x6f, 0x72, 0x79, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f,
		0x1c, 0xb7, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x46, 0x75, 0x6c,
		0x6c, 0x54, 0x79, 0x70, 0x65, 0x5f, 0x7a, 0x69, 0x64, 0x2d,
		0x31, 0x5f, 0x70, 0x74, 0x72, 0x83, 0xab, 0x4b, 0x69, 0x6e,
		0x64, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x1c, 0xad,
		0x53, 0x74, 0x72, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f,
		0x73, 0x74, 0x72, 0xa7, 0x50, 0x6f, 0x69, 0x6e, 0x74, 0x65,
		0x72, 0xb0, 0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x5f, 0x7a,
		0x69, 0x64, 0x2d, 0x31, 0x5f, 0x70, 0x74, 0x72, 0x82, 0xab,
		0x4b, 0x69, 0x6e, 0x64, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31,
		0x5f, 0x16, 0xad, 0x53, 0x74, 0x72, 0x5f, 0x7a, 0x69, 0x64,
		0x2d, 0x31, 0x5f, 0x73, 0x74, 0x72, 0xa5, 0x5a, 0x74, 0x79,
		0x70, 0x65, 0xb3, 0x4f, 0x6d, 0x69, 0x74, 0x45, 0x6d, 0x70,
		0x74, 0x79, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x62,
		0x6f, 0x6f, 0xc3, 0x88, 0xad, 0x5a, 0x69, 0x64, 0x5f, 0x7a,
		0x69, 0x64, 0x2d, 0x31, 0x5f, 0x69, 0x36, 0x34, 0xff, 0xb5,
		0x46, 0x69, 0x65, 0x6c, 0x64, 0x47, 0x6f, 0x4e, 0x61, 0x6d,
		0x65, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x73, 0x74,
		0x72, 0xa9, 0x4f, 0x6d, 0x69, 0x74, 0x45, 0x6d, 0x70, 0x74,
		0x79, 0xb6, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x54, 0x61, 0x67,
		0x4e, 0x61, 0x6d, 0x65, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31,
		0x5f, 0x73, 0x74, 0x72, 0xa9, 0x4f, 0x6d, 0x69, 0x74, 0x45,
		0x6d, 0x70, 0x74, 0x79, 0xb6, 0x46, 0x69, 0x65, 0x6c, 0x64,
		0x54, 0x79, 0x70, 0x65, 0x53, 0x74, 0x72, 0x5f, 0x7a, 0x69,
		0x64, 0x2d, 0x31, 0x5f, 0x73, 0x74, 0x72, 0xa4, 0x62, 0x6f,
		0x6f, 0x6c, 0xb4, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x43, 0x61,
		0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x5f, 0x7a, 0x69, 0x64,
		0x2d, 0x31, 0x5f, 0x17, 0xb5, 0x46, 0x69, 0x65, 0x6c, 0x64,
		0x50, 0x72, 0x69, 0x6d, 0x69, 0x74, 0x69, 0x76, 0x65, 0x5f,
		0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x12, 0xb7, 0x46, 0x69,
		0x65, 0x6c, 0x64, 0x46, 0x75, 0x6c, 0x6c, 0x54, 0x79, 0x70,
		0x65, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x70, 0x74,
		0x72, 0x82, 0xab, 0x4b, 0x69, 0x6e, 0x64, 0x5f, 0x7a, 0x69,
		0x64, 0x2d, 0x31, 0x5f, 0x12, 0xad, 0x53, 0x74, 0x72, 0x5f,
		0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x73, 0x74, 0x72, 0xa4,
		0x62, 0x6f, 0x6f, 0x6c, 0xb3, 0x4f, 0x6d, 0x69, 0x74, 0x45,
		0x6d, 0x70, 0x74, 0x79, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31,
		0x5f, 0x62, 0x6f, 0x6f, 0xc3, 0x88, 0xad, 0x5a, 0x69, 0x64,
		0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x69, 0x36, 0x34,
		0xff, 0xb5, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x47, 0x6f, 0x4e,
		0x61, 0x6d, 0x65, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f,
		0x73, 0x74, 0x72, 0xa4, 0x53, 0x6b, 0x69, 0x70, 0xb6, 0x46,
		0x69, 0x65, 0x6c, 0x64, 0x54, 0x61, 0x67, 0x4e, 0x61, 0x6d,
		0x65, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x73, 0x74,
		0x72, 0xa4, 0x53, 0x6b, 0x69, 0x70, 0xb6, 0x46, 0x69, 0x65,
		0x6c, 0x64, 0x54, 0x79, 0x70, 0x65, 0x53, 0x74, 0x72, 0x5f,
		0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x73, 0x74, 0x72, 0xa4,
		0x62, 0x6f, 0x6f, 0x6c, 0xb4, 0x46, 0x69, 0x65, 0x6c, 0x64,
		0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x5f, 0x7a,
		0x69, 0x64, 0x2d, 0x31, 0x5f, 0x17, 0xb5, 0x46, 0x69, 0x65,
		0x6c, 0x64, 0x50, 0x72, 0x69, 0x6d, 0x69, 0x74, 0x69, 0x76,
		0x65, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x12, 0xb7,
		0x46, 0x69, 0x65, 0x6c, 0x64, 0x46, 0x75, 0x6c, 0x6c, 0x54,
		0x79, 0x70, 0x65, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f,
		0x70, 0x74, 0x72, 0x82, 0xab, 0x4b, 0x69, 0x6e, 0x64, 0x5f,
		0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x12, 0xad, 0x53, 0x74,
		0x72, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x73, 0x74,
		0x72, 0xa4, 0x62, 0x6f, 0x6f, 0x6c, 0xb3, 0x4f, 0x6d, 0x69,
		0x74, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x5f, 0x7a, 0x69, 0x64,
		0x2d, 0x31, 0x5f, 0x62, 0x6f, 0x6f, 0xc3, 0x88, 0xad, 0x5a,
		0x69, 0x64, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x69,
		0x36, 0x34, 0xff, 0xb5, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x47,
		0x6f, 0x4e, 0x61, 0x6d, 0x65, 0x5f, 0x7a, 0x69, 0x64, 0x2d,
		0x31, 0x5f, 0x73, 0x74, 0x72, 0xaa, 0x44, 0x65, 0x70, 0x72,
		0x65, 0x63, 0x61, 0x74, 0x65, 0x64, 0xb6, 0x46, 0x69, 0x65,
		0x6c, 0x64, 0x54, 0x61, 0x67, 0x4e, 0x61, 0x6d, 0x65, 0x5f,
		0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x73, 0x74, 0x72, 0xaa,
		0x44, 0x65, 0x70, 0x72, 0x65, 0x63, 0x61, 0x74, 0x65, 0x64,
		0xb6, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x54, 0x79, 0x70, 0x65,
		0x53, 0x74, 0x72, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f,
		0x73, 0x74, 0x72, 0xa4, 0x62, 0x6f, 0x6f, 0x6c, 0xb4, 0x46,
		0x69, 0x65, 0x6c, 0x64, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f,
		0x72, 0x79, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x17,
		0xb5, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x50, 0x72, 0x69, 0x6d,
		0x69, 0x74, 0x69, 0x76, 0x65, 0x5f, 0x7a, 0x69, 0x64, 0x2d,
		0x31, 0x5f, 0x12, 0xb7, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x46,
		0x75, 0x6c, 0x6c, 0x54, 0x79, 0x70, 0x65, 0x5f, 0x7a, 0x69,
		0x64, 0x2d, 0x31, 0x5f, 0x70, 0x74, 0x72, 0x82, 0xab, 0x4b,
		0x69, 0x6e, 0x64, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f,
		0x12, 0xad, 0x53, 0x74, 0x72, 0x5f, 0x7a, 0x69, 0x64, 0x2d,
		0x31, 0x5f, 0x73, 0x74, 0x72, 0xa4, 0x62, 0x6f, 0x6f, 0x6c,
		0xb3, 0x4f, 0x6d, 0x69, 0x74, 0x45, 0x6d, 0x70, 0x74, 0x79,
		0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x62, 0x6f, 0x6f,
		0xc3, 0x88, 0xad, 0x5a, 0x69, 0x64, 0x5f, 0x7a, 0x69, 0x64,
		0x2d, 0x31, 0x5f, 0x69, 0x36, 0x34, 0xff, 0xb5, 0x46, 0x69,
		0x65, 0x6c, 0x64, 0x47, 0x6f, 0x4e, 0x61, 0x6d, 0x65, 0x5f,
		0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x73, 0x74, 0x72, 0xa8,
		0x53, 0x68, 0x6f, 0x77, 0x5a, 0x65, 0x72, 0x6f, 0xb6, 0x46,
		0x69, 0x65, 0x6c, 0x64, 0x54, 0x61, 0x67, 0x4e, 0x61, 0x6d,
		0x65, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x73, 0x74,
		0x72, 0xa8, 0x53, 0x68, 0x6f, 0x77, 0x5a, 0x65, 0x72, 0x6f,
		0xb6, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x54, 0x79, 0x70, 0x65,
		0x53, 0x74, 0x72, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f,
		0x73, 0x74, 0x72, 0xa4, 0x62, 0x6f, 0x6f, 0x6c, 0xb4, 0x46,
		0x69, 0x65, 0x6c, 0x64, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f,
		0x72, 0x79, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x17,
		0xb5, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x50, 0x72, 0x69, 0x6d,
		0x69, 0x74, 0x69, 0x76, 0x65, 0x5f, 0x7a, 0x69, 0x64, 0x2d,
		0x31, 0x5f, 0x12, 0xb7, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x46,
		0x75, 0x6c, 0x6c, 0x54, 0x79, 0x70, 0x65, 0x5f, 0x7a, 0x69,
		0x64, 0x2d, 0x31, 0x5f, 0x70, 0x74, 0x72, 0x82, 0xab, 0x4b,
		0x69, 0x6e, 0x64, 0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f,
		0x12, 0xad, 0x53, 0x74, 0x72, 0x5f, 0x7a, 0x69, 0x64, 0x2d,
		0x31, 0x5f, 0x73, 0x74, 0x72, 0xa4, 0x62, 0x6f, 0x6f, 0x6c,
		0xb3, 0x4f, 0x6d, 0x69, 0x74, 0x45, 0x6d, 0x70, 0x74, 0x79,
		0x5f, 0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x62, 0x6f, 0x6f,
		0xc3, 0xb1, 0x49, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x73, 0x5f,
		0x7a, 0x69, 0x64, 0x2d, 0x31, 0x5f, 0x73, 0x6c, 0x63, 0x90,
	}
}

// ZebraSchemaInJsonCompact provides the Greenpack Schema in compact JSON format, length 6556 bytes
func (FileZebra) ZebraSchemaInJsonCompact() []byte {
	return []byte(`{"SourcePath_zid-1_str":"zebra.go","SourcePackage_zid-1_str":"zebra","ZebraSchemaId_zid-1_i64":463621516989988,"Structs_zid-1_map":{"Ztype":{"StructName_zid-1_str":"Ztype","Fields_zid-1_slc":[{"Zid_zid-1_i64":-1,"FieldGoName_zid-1_str":"Kind","FieldTagName_zid-1_str":"Kind","FieldTypeStr_zid-1_str":"Zkind","FieldCategory_zid-1_":23,"FieldPrimitive_zid-1_":11,"FieldFullType_zid-1_ptr":{"Kind_zid-1_":11,"Str_zid-1_str":"uint64"}},{"Zid_zid-1_i64":-1,"FieldGoName_zid-1_str":"Str","FieldTagName_zid-1_str":"Str","FieldTypeStr_zid-1_str":"string","FieldCategory_zid-1_":23,"FieldPrimitive_zid-1_":2,"FieldFullType_zid-1_ptr":{"Kind_zid-1_":2,"Str_zid-1_str":"string"},"OmitEmpty_zid-1_boo":true},{"Zid_zid-1_i64":-1,"FieldGoName_zid-1_str":"Domain","FieldTagName_zid-1_str":"Domain","FieldTypeStr_zid-1_str":"*Ztype","FieldCategory_zid-1_":28,"FieldFullType_zid-1_ptr":{"Kind_zid-1_":28,"Str_zid-1_str":"Pointer","Domain_zid-1_ptr":{"Kind_zid-1_":22,"Str_zid-1_str":"Ztype"}},"OmitEmpty_zid-1_boo":true},{"Zid_zid-1_i64":-1,"FieldGoName_zid-1_str":"Range","FieldTagName_zid-1_str":"Range","FieldTypeStr_zid-1_str":"*Ztype","FieldCategory_zid-1_":28,"FieldFullType_zid-1_ptr":{"Kind_zid-1_":28,"Str_zid-1_str":"Pointer","Domain_zid-1_ptr":{"Kind_zid-1_":22,"Str_zid-1_str":"Ztype"}},"OmitEmpty_zid-1_boo":true}]},"Schema":{"StructName_zid-1_str":"Schema","Fields_zid-1_slc":[{"Zid_zid-1_i64":-1,"FieldGoName_zid-1_str":"SourcePath","FieldTagName_zid-1_str":"SourcePath","FieldTypeStr_zid-1_str":"string","FieldCategory_zid-1_":23,"FieldPrimitive_zid-1_":2,"FieldFullType_zid-1_ptr":{"Kind_zid-1_":2,"Str_zid-1_str":"string"}},{"Zid_zid-1_i64":-1,"FieldGoName_zid-1_str":"SourcePackage","FieldTagName_zid-1_str":"SourcePackage","FieldTypeStr_zid-1_str":"string","FieldCategory_zid-1_":23,"FieldPrimitive_zid-1_":2,"FieldFullType_zid-1_ptr":{"Kind_zid-1_":2,"Str_zid-1_str":"string"}},{"Zid_zid-1_i64":-1,"FieldGoName_zid-1_str":"ZebraSchemaId","FieldTagName_zid-1_str":"ZebraSchemaId","FieldTypeStr_zid-1_str":"int64","FieldCategory_zid-1_":23,"FieldPrimitive_zid-1_":17,"FieldFullType_zid-1_ptr":{"Kind_zid-1_":17,"Str_zid-1_str":"int64"}},{"Zid_zid-1_i64":-1,"FieldGoName_zid-1_str":"Structs","FieldTagName_zid-1_str":"Structs","FieldTypeStr_zid-1_str":"map[string]*Struct","FieldCategory_zid-1_":24,"FieldFullType_zid-1_ptr":{"Kind_zid-1_":24,"Str_zid-1_str":"Map","Domain_zid-1_ptr":{"Kind_zid-1_":2,"Str_zid-1_str":"string"},"Range_zid-1_ptr":{"Kind_zid-1_":28,"Str_zid-1_str":"Pointer","Domain_zid-1_ptr":{"Kind_zid-1_":25,"Str_zid-1_str":"Struct"}}}},{"Zid_zid-1_i64":-1,"FieldGoName_zid-1_str":"Imports","FieldTagName_zid-1_str":"Imports","FieldTypeStr_zid-1_str":"[]string","FieldCategory_zid-1_":26,"FieldFullType_zid-1_ptr":{"Kind_zid-1_":26,"Str_zid-1_str":"Slice","Domain_zid-1_ptr":{"Kind_zid-1_":2,"Str_zid-1_str":"string"}}}]},"Struct":{"StructName_zid-1_str":"Struct","Fields_zid-1_slc":[{"Zid_zid-1_i64":-1,"FieldGoName_zid-1_str":"StructName","FieldTagName_zid-1_str":"StructName","FieldTypeStr_zid-1_str":"string","FieldCategory_zid-1_":23,"FieldPrimitive_zid-1_":2,"FieldFullType_zid-1_ptr":{"Kind_zid-1_":2,"Str_zid-1_str":"string"}},{"Zid_zid-1_i64":-1,"FieldGoName_zid-1_str":"Fields","FieldTagName_zid-1_str":"Fields","FieldTypeStr_zid-1_str":"[]Field","FieldCategory_zid-1_":26,"FieldFullType_zid-1_ptr":{"Kind_zid-1_":26,"Str_zid-1_str":"Slice","Domain_zid-1_ptr":{"Kind_zid-1_":22,"Str_zid-1_str":"Field"}}}]},"Field":{"StructName_zid-1_str":"Field","Fields_zid-1_slc":[{"Zid_zid-1_i64":-1,"FieldGoName_zid-1_str":"Zid","FieldTagName_zid-1_str":"Zid","FieldTypeStr_zid-1_str":"int64","FieldCategory_zid-1_":23,"FieldPrimitive_zid-1_":17,"FieldFullType_zid-1_ptr":{"Kind_zid-1_":17,"Str_zid-1_str":"int64"}},{"Zid_zid-1_i64":-1,"FieldGoName_zid-1_str":"FieldGoName","FieldTagName_zid-1_str":"FieldGoName","FieldTypeStr_zid-1_str":"string","FieldCategory_zid-1_":23,"FieldPrimitive_zid-1_":2,"FieldFullType_zid-1_ptr":{"Kind_zid-1_":2,"Str_zid-1_str":"string"}},{"Zid_zid-1_i64":-1,"FieldGoName_zid-1_str":"FieldTagName","FieldTagName_zid-1_str":"FieldTagName","FieldTypeStr_zid-1_str":"string","FieldCategory_zid-1_":23,"FieldPrimitive_zid-1_":2,"FieldFullType_zid-1_ptr":{"Kind_zid-1_":2,"Str_zid-1_str":"string"},"OmitEmpty_zid-1_boo":true},{"Zid_zid-1_i64":-1,"FieldGoName_zid-1_str":"FieldTypeStr","FieldTagName_zid-1_str":"FieldTypeStr","FieldTypeStr_zid-1_str":"string","FieldCategory_zid-1_":23,"FieldPrimitive_zid-1_":2,"FieldFullType_zid-1_ptr":{"Kind_zid-1_":2,"Str_zid-1_str":"string"},"OmitEmpty_zid-1_boo":true},{"Zid_zid-1_i64":-1,"FieldGoName_zid-1_str":"FieldCategory","FieldTagName_zid-1_str":"FieldCategory","FieldTypeStr_zid-1_str":"Zkind","FieldCategory_zid-1_":23,"FieldPrimitive_zid-1_":11,"FieldFullType_zid-1_ptr":{"Kind_zid-1_":11,"Str_zid-1_str":"uint64"},"OmitEmpty_zid-1_boo":true},{"Zid_zid-1_i64":-1,"FieldGoName_zid-1_str":"FieldPrimitive","FieldTagName_zid-1_str":"FieldPrimitive","FieldTypeStr_zid-1_str":"Zkind","FieldCategory_zid-1_":23,"FieldPrimitive_zid-1_":11,"FieldFullType_zid-1_ptr":{"Kind_zid-1_":11,"Str_zid-1_str":"uint64"},"OmitEmpty_zid-1_boo":true},{"Zid_zid-1_i64":-1,"FieldGoName_zid-1_str":"FieldFullType","FieldTagName_zid-1_str":"FieldFullType","FieldTypeStr_zid-1_str":"*Ztype","FieldCategory_zid-1_":28,"FieldFullType_zid-1_ptr":{"Kind_zid-1_":28,"Str_zid-1_str":"Pointer","Domain_zid-1_ptr":{"Kind_zid-1_":22,"Str_zid-1_str":"Ztype"}},"OmitEmpty_zid-1_boo":true},{"Zid_zid-1_i64":-1,"FieldGoName_zid-1_str":"OmitEmpty","FieldTagName_zid-1_str":"OmitEmpty","FieldTypeStr_zid-1_str":"bool","FieldCategory_zid-1_":23,"FieldPrimitive_zid-1_":18,"FieldFullType_zid-1_ptr":{"Kind_zid-1_":18,"Str_zid-1_str":"bool"},"OmitEmpty_zid-1_boo":true},{"Zid_zid-1_i64":-1,"FieldGoName_zid-1_str":"Skip","FieldTagName_zid-1_str":"Skip","FieldTypeStr_zid-1_str":"bool","FieldCategory_zid-1_":23,"FieldPrimitive_zid-1_":18,"FieldFullType_zid-1_ptr":{"Kind_zid-1_":18,"Str_zid-1_str":"bool"},"OmitEmpty_zid-1_boo":true},{"Zid_zid-1_i64":-1,"FieldGoName_zid-1_str":"Deprecated","FieldTagName_zid-1_str":"Deprecated","FieldTypeStr_zid-1_str":"bool","FieldCategory_zid-1_":23,"FieldPrimitive_zid-1_":18,"FieldFullType_zid-1_ptr":{"Kind_zid-1_":18,"Str_zid-1_str":"bool"},"OmitEmpty_zid-1_boo":true},{"Zid_zid-1_i64":-1,"FieldGoName_zid-1_str":"ShowZero","FieldTagName_zid-1_str":"ShowZero","FieldTypeStr_zid-1_str":"bool","FieldCategory_zid-1_":23,"FieldPrimitive_zid-1_":18,"FieldFullType_zid-1_ptr":{"Kind_zid-1_":18,"Str_zid-1_str":"bool"},"OmitEmpty_zid-1_boo":true}]}},"Imports_zid-1_slc":[]}`)
}

// ZebraSchemaInJsonPretty provides the Greenpack Schema in pretty JSON format, length 13610 bytes
func (FileZebra) ZebraSchemaInJsonPretty() []byte {
	return []byte(`{
    "SourcePath_zid-1_str": "zebra.go",
    "SourcePackage_zid-1_str": "zebra",
    "ZebraSchemaId_zid-1_i64": 463621516989988,
    "Structs_zid-1_map": {
        "Ztype": {
            "StructName_zid-1_str": "Ztype",
            "Fields_zid-1_slc": [
                {
                    "Zid_zid-1_i64": -1,
                    "FieldGoName_zid-1_str": "Kind",
                    "FieldTagName_zid-1_str": "Kind",
                    "FieldTypeStr_zid-1_str": "Zkind",
                    "FieldCategory_zid-1_": 23,
                    "FieldPrimitive_zid-1_": 11,
                    "FieldFullType_zid-1_ptr": {
                        "Kind_zid-1_": 11,
                        "Str_zid-1_str": "uint64"
                    }
                },
                {
                    "Zid_zid-1_i64": -1,
                    "FieldGoName_zid-1_str": "Str",
                    "FieldTagName_zid-1_str": "Str",
                    "FieldTypeStr_zid-1_str": "string",
                    "FieldCategory_zid-1_": 23,
                    "FieldPrimitive_zid-1_": 2,
                    "FieldFullType_zid-1_ptr": {
                        "Kind_zid-1_": 2,
                        "Str_zid-1_str": "string"
                    },
                    "OmitEmpty_zid-1_boo": true
                },
                {
                    "Zid_zid-1_i64": -1,
                    "FieldGoName_zid-1_str": "Domain",
                    "FieldTagName_zid-1_str": "Domain",
                    "FieldTypeStr_zid-1_str": "*Ztype",
                    "FieldCategory_zid-1_": 28,
                    "FieldFullType_zid-1_ptr": {
                        "Kind_zid-1_": 28,
                        "Str_zid-1_str": "Pointer",
                        "Domain_zid-1_ptr": {
                            "Kind_zid-1_": 22,
                            "Str_zid-1_str": "Ztype"
                        }
                    },
                    "OmitEmpty_zid-1_boo": true
                },
                {
                    "Zid_zid-1_i64": -1,
                    "FieldGoName_zid-1_str": "Range",
                    "FieldTagName_zid-1_str": "Range",
                    "FieldTypeStr_zid-1_str": "*Ztype",
                    "FieldCategory_zid-1_": 28,
                    "FieldFullType_zid-1_ptr": {
                        "Kind_zid-1_": 28,
                        "Str_zid-1_str": "Pointer",
                        "Domain_zid-1_ptr": {
                            "Kind_zid-1_": 22,
                            "Str_zid-1_str": "Ztype"
                        }
                    },
                    "OmitEmpty_zid-1_boo": true
                }
            ]
        },
        "Schema": {
            "StructName_zid-1_str": "Schema",
            "Fields_zid-1_slc": [
                {
                    "Zid_zid-1_i64": -1,
                    "FieldGoName_zid-1_str": "SourcePath",
                    "FieldTagName_zid-1_str": "SourcePath",
                    "FieldTypeStr_zid-1_str": "string",
                    "FieldCategory_zid-1_": 23,
                    "FieldPrimitive_zid-1_": 2,
                    "FieldFullType_zid-1_ptr": {
                        "Kind_zid-1_": 2,
                        "Str_zid-1_str": "string"
                    }
                },
                {
                    "Zid_zid-1_i64": -1,
                    "FieldGoName_zid-1_str": "SourcePackage",
                    "FieldTagName_zid-1_str": "SourcePackage",
                    "FieldTypeStr_zid-1_str": "string",
                    "FieldCategory_zid-1_": 23,
                    "FieldPrimitive_zid-1_": 2,
                    "FieldFullType_zid-1_ptr": {
                        "Kind_zid-1_": 2,
                        "Str_zid-1_str": "string"
                    }
                },
                {
                    "Zid_zid-1_i64": -1,
                    "FieldGoName_zid-1_str": "ZebraSchemaId",
                    "FieldTagName_zid-1_str": "ZebraSchemaId",
                    "FieldTypeStr_zid-1_str": "int64",
                    "FieldCategory_zid-1_": 23,
                    "FieldPrimitive_zid-1_": 17,
                    "FieldFullType_zid-1_ptr": {
                        "Kind_zid-1_": 17,
                        "Str_zid-1_str": "int64"
                    }
                },
                {
                    "Zid_zid-1_i64": -1,
                    "FieldGoName_zid-1_str": "Structs",
                    "FieldTagName_zid-1_str": "Structs",
                    "FieldTypeStr_zid-1_str": "map[string]*Struct",
                    "FieldCategory_zid-1_": 24,
                    "FieldFullType_zid-1_ptr": {
                        "Kind_zid-1_": 24,
                        "Str_zid-1_str": "Map",
                        "Domain_zid-1_ptr": {
                            "Kind_zid-1_": 2,
                            "Str_zid-1_str": "string"
                        },
                        "Range_zid-1_ptr": {
                            "Kind_zid-1_": 28,
                            "Str_zid-1_str": "Pointer",
                            "Domain_zid-1_ptr": {
                                "Kind_zid-1_": 25,
                                "Str_zid-1_str": "Struct"
                            }
                        }
                    }
                },
                {
                    "Zid_zid-1_i64": -1,
                    "FieldGoName_zid-1_str": "Imports",
                    "FieldTagName_zid-1_str": "Imports",
                    "FieldTypeStr_zid-1_str": "[]string",
                    "FieldCategory_zid-1_": 26,
                    "FieldFullType_zid-1_ptr": {
                        "Kind_zid-1_": 26,
                        "Str_zid-1_str": "Slice",
                        "Domain_zid-1_ptr": {
                            "Kind_zid-1_": 2,
                            "Str_zid-1_str": "string"
                        }
                    }
                }
            ]
        },
        "Struct": {
            "StructName_zid-1_str": "Struct",
            "Fields_zid-1_slc": [
                {
                    "Zid_zid-1_i64": -1,
                    "FieldGoName_zid-1_str": "StructName",
                    "FieldTagName_zid-1_str": "StructName",
                    "FieldTypeStr_zid-1_str": "string",
                    "FieldCategory_zid-1_": 23,
                    "FieldPrimitive_zid-1_": 2,
                    "FieldFullType_zid-1_ptr": {
                        "Kind_zid-1_": 2,
                        "Str_zid-1_str": "string"
                    }
                },
                {
                    "Zid_zid-1_i64": -1,
                    "FieldGoName_zid-1_str": "Fields",
                    "FieldTagName_zid-1_str": "Fields",
                    "FieldTypeStr_zid-1_str": "[]Field",
                    "FieldCategory_zid-1_": 26,
                    "FieldFullType_zid-1_ptr": {
                        "Kind_zid-1_": 26,
                        "Str_zid-1_str": "Slice",
                        "Domain_zid-1_ptr": {
                            "Kind_zid-1_": 22,
                            "Str_zid-1_str": "Field"
                        }
                    }
                }
            ]
        },
        "Field": {
            "StructName_zid-1_str": "Field",
            "Fields_zid-1_slc": [
                {
                    "Zid_zid-1_i64": -1,
                    "FieldGoName_zid-1_str": "Zid",
                    "FieldTagName_zid-1_str": "Zid",
                    "FieldTypeStr_zid-1_str": "int64",
                    "FieldCategory_zid-1_": 23,
                    "FieldPrimitive_zid-1_": 17,
                    "FieldFullType_zid-1_ptr": {
                        "Kind_zid-1_": 17,
                        "Str_zid-1_str": "int64"
                    }
                },
                {
                    "Zid_zid-1_i64": -1,
                    "FieldGoName_zid-1_str": "FieldGoName",
                    "FieldTagName_zid-1_str": "FieldGoName",
                    "FieldTypeStr_zid-1_str": "string",
                    "FieldCategory_zid-1_": 23,
                    "FieldPrimitive_zid-1_": 2,
                    "FieldFullType_zid-1_ptr": {
                        "Kind_zid-1_": 2,
                        "Str_zid-1_str": "string"
                    }
                },
                {
                    "Zid_zid-1_i64": -1,
                    "FieldGoName_zid-1_str": "FieldTagName",
                    "FieldTagName_zid-1_str": "FieldTagName",
                    "FieldTypeStr_zid-1_str": "string",
                    "FieldCategory_zid-1_": 23,
                    "FieldPrimitive_zid-1_": 2,
                    "FieldFullType_zid-1_ptr": {
                        "Kind_zid-1_": 2,
                        "Str_zid-1_str": "string"
                    },
                    "OmitEmpty_zid-1_boo": true
                },
                {
                    "Zid_zid-1_i64": -1,
                    "FieldGoName_zid-1_str": "FieldTypeStr",
                    "FieldTagName_zid-1_str": "FieldTypeStr",
                    "FieldTypeStr_zid-1_str": "string",
                    "FieldCategory_zid-1_": 23,
                    "FieldPrimitive_zid-1_": 2,
                    "FieldFullType_zid-1_ptr": {
                        "Kind_zid-1_": 2,
                        "Str_zid-1_str": "string"
                    },
                    "OmitEmpty_zid-1_boo": true
                },
                {
                    "Zid_zid-1_i64": -1,
                    "FieldGoName_zid-1_str": "FieldCategory",
                    "FieldTagName_zid-1_str": "FieldCategory",
                    "FieldTypeStr_zid-1_str": "Zkind",
                    "FieldCategory_zid-1_": 23,
                    "FieldPrimitive_zid-1_": 11,
                    "FieldFullType_zid-1_ptr": {
                        "Kind_zid-1_": 11,
                        "Str_zid-1_str": "uint64"
                    },
                    "OmitEmpty_zid-1_boo": true
                },
                {
                    "Zid_zid-1_i64": -1,
                    "FieldGoName_zid-1_str": "FieldPrimitive",
                    "FieldTagName_zid-1_str": "FieldPrimitive",
                    "FieldTypeStr_zid-1_str": "Zkind",
                    "FieldCategory_zid-1_": 23,
                    "FieldPrimitive_zid-1_": 11,
                    "FieldFullType_zid-1_ptr": {
                        "Kind_zid-1_": 11,
                        "Str_zid-1_str": "uint64"
                    },
                    "OmitEmpty_zid-1_boo": true
                },
                {
                    "Zid_zid-1_i64": -1,
                    "FieldGoName_zid-1_str": "FieldFullType",
                    "FieldTagName_zid-1_str": "FieldFullType",
                    "FieldTypeStr_zid-1_str": "*Ztype",
                    "FieldCategory_zid-1_": 28,
                    "FieldFullType_zid-1_ptr": {
                        "Kind_zid-1_": 28,
                        "Str_zid-1_str": "Pointer",
                        "Domain_zid-1_ptr": {
                            "Kind_zid-1_": 22,
                            "Str_zid-1_str": "Ztype"
                        }
                    },
                    "OmitEmpty_zid-1_boo": true
                },
                {
                    "Zid_zid-1_i64": -1,
                    "FieldGoName_zid-1_str": "OmitEmpty",
                    "FieldTagName_zid-1_str": "OmitEmpty",
                    "FieldTypeStr_zid-1_str": "bool",
                    "FieldCategory_zid-1_": 23,
                    "FieldPrimitive_zid-1_": 18,
                    "FieldFullType_zid-1_ptr": {
                        "Kind_zid-1_": 18,
                        "Str_zid-1_str": "bool"
                    },
                    "OmitEmpty_zid-1_boo": true
                },
                {
                    "Zid_zid-1_i64": -1,
                    "FieldGoName_zid-1_str": "Skip",
                    "FieldTagName_zid-1_str": "Skip",
                    "FieldTypeStr_zid-1_str": "bool",
                    "FieldCategory_zid-1_": 23,
                    "FieldPrimitive_zid-1_": 18,
                    "FieldFullType_zid-1_ptr": {
                        "Kind_zid-1_": 18,
                        "Str_zid-1_str": "bool"
                    },
                    "OmitEmpty_zid-1_boo": true
                },
                {
                    "Zid_zid-1_i64": -1,
                    "FieldGoName_zid-1_str": "Deprecated",
                    "FieldTagName_zid-1_str": "Deprecated",
                    "FieldTypeStr_zid-1_str": "bool",
                    "FieldCategory_zid-1_": 23,
                    "FieldPrimitive_zid-1_": 18,
                    "FieldFullType_zid-1_ptr": {
                        "Kind_zid-1_": 18,
                        "Str_zid-1_str": "bool"
                    },
                    "OmitEmpty_zid-1_boo": true
                },
                {
                    "Zid_zid-1_i64": -1,
                    "FieldGoName_zid-1_str": "ShowZero",
                    "FieldTagName_zid-1_str": "ShowZero",
                    "FieldTypeStr_zid-1_str": "bool",
                    "FieldCategory_zid-1_": 23,
                    "FieldPrimitive_zid-1_": 18,
                    "FieldFullType_zid-1_ptr": {
                        "Kind_zid-1_": 18,
                        "Str_zid-1_str": "bool"
                    },
                    "OmitEmpty_zid-1_boo": true
                }
            ]
        }
    },
    "Imports_zid-1_slc": []
}`)
}
